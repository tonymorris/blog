<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>λ Tony's blog λ - Improving Applicative do-notation</title>
  <link rel="stylesheet" type="text/css" href="../../css/screen.css" />
  <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
  <link rel="alternate" type="application/atom+xml" href="http://blog.tmorris.net/atom.xml" title="Atom feed" />
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src="https://raw.github.com/Mathapedia/LaTeX2HTML5/master/latex2html5.min.js"></script>
</head>
<body>
<div id="title">
  λ Tony's blog λ
  <div id="subtitle">
    The weblog of Tony Morris
  </div>
</div>
<div id="header">
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../posts/">All Posts</a>
    <a href="../../contact/">Contact</a>
    <a href="http://cv.tmorris.net/">CV</a>
    <a href="../../atom.xml"><img src="../../images/feed-icon-14x14.png" alt="feed" /></a>
  </div>
</div>
<h1>Improving Applicative do-notation</h1>
<div class="info">Posted on October 18, 2013, in <a href="../../tags/Programming/index.html">Programming</a>, <a href="../../tags/Haskell/index.html">Haskell</a>, <a href="../../tags/Applicative/index.html">Applicative</a>, <a href="../../tags/Monad/index.html">Monad</a>, <a href="../../tags/Apply/index.html">Apply</a>, <a href="../../tags/Bind/index.html">Bind</a>, <a href="../../tags/Functor/index.html">Functor</a></div>

<h3 id="monad-and-functor">Monad and Functor</h3>
<p>The <a href="http://haskell.org/">Haskell programming language</a> has a <code>Monad</code> type-class as well as a <code>Functor</code> type-class. It is possible to derive the <code>Functor</code> primitive (<code>fmap</code>) from the <code>Monad</code> primitives:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- derive fmap from the Monad primitives, (&gt;&gt;=) and return</span>
fmap f x <span class="fu">=</span>
  x <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> f</code></pre>
<p>Therefore, it is reasonably argued that <code>Monad</code> should extend <code>Functor</code> so as to provide this default definition of <code>fmap</code>. Due to history, this is not the case, which leads to some awkward situations.</p>
<p>For example, since not all <code>Functor</code> instances are <code>Monad</code> instances, a given operation may wish to restrict itself (if possible) to <code>Functor</code> so that it can be used against those data types. In short, use <code>fmap</code> instead of <code>liftM</code> to prevent an unnecessary constraint on the type of the operation.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">fFlip <span class="ot">::</span>
  <span class="dt">Functor</span> f <span class="ot">=&gt;</span>
  f (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> a
  <span class="ot">-&gt;</span> f b
fFlip f a <span class="fu">=</span>
  fmap (<span class="fu">$</span>a) f

mFlip <span class="ot">::</span>
  <span class="dt">Monad</span> f <span class="ot">=&gt;</span>
  f (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> a
  <span class="ot">-&gt;</span> f b
mFlip f a <span class="fu">=</span>
  liftM (<span class="fu">$</span>a) f</code></pre>
<p>The <code>fFlip</code> is available to use to a strict superset of the data types that <code>mFlip</code> is available to, yet they are both equivalent in power. It is desirable to implement <code>fFlip</code>. However, when we combine a usage of <code>fFlip</code> with a monad operation, our type constraint becomes <code>(Monad f, Functor f) =&gt;</code>, which is undesirable boilerplate because <code>Monad</code> implies <code>Functor</code>!</p>
<h3 id="monad-applicative-and-functor">Monad, Applicative and Functor</h3>
<p>A <a href="http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal">proposal to amend this introduces the <code>Applicative</code> type-class</a>, which sits between <code>Monad</code> and <code>Functor</code>. In other words, <code>Monad</code> extends <code>Applicative</code> and <code>Applicative</code> extends <code>Functor</code>. This is again, because the primitives of each superclass can be derived:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- derive fmap from the Applicative primitives, (&lt;*&gt;) and pure</span>
fmap <span class="ot">::</span>
  <span class="dt">Applicative</span> f <span class="ot">=&gt;</span>
  (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> f a
  <span class="ot">-&gt;</span> f b
fmap <span class="fu">=</span>
  (<span class="fu">&lt;*&gt;</span>) <span class="fu">.</span> pure

<span class="co">-- derive (&lt;*&gt;) and pure from the Monad primitives, (&gt;&gt;=) and return</span>
(<span class="fu">&lt;*&gt;</span>) <span class="ot">::</span>
  <span class="dt">Monad</span> f <span class="ot">=&gt;</span>
  f (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> f a
  <span class="ot">-&gt;</span> f b
f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span>
  <span class="kw">do</span> f' <span class="ot">&lt;-</span> f
     a' <span class="ot">&lt;-</span> a
     return (f' a')

pure <span class="ot">::</span>
  <span class="dt">Monad</span> f <span class="ot">=&gt;</span>
  a
  <span class="ot">-&gt;</span> f a
pure <span class="fu">=</span>
  return</code></pre>
<h3 id="applicative-do-notation">Applicative do-notation</h3>
<p>With this proposal, there is <a href="http://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo">another proposal to extend do-notation</a> to take advantage of this improved flexibility. Currently, do-notation translates to the code that uses the <code>Monad</code> primitives, <code>(&gt;&gt;=)</code> and <code>return</code><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>There are some arguments against this proposal, because this extension is not always desirable. In particular, the degree to which values are shared may be affected. Consider:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">result <span class="fu">=</span>
  <span class="kw">do</span> a <span class="ot">&lt;-</span> expr
     b <span class="ot">&lt;-</span> spaceyExpr
     return (f a b)

<span class="co">-- monad desugaring (current)</span>
result <span class="fu">=</span>
  expr <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span>
  spaceyExpr <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>
  return (f a b)

<span class="co">-- applicative desugaring (proposed)</span>
result <span class="fu">=</span>
  fmap f expr <span class="fu">&lt;*&gt;</span> spaceyExpr</code></pre>
<p>Since <code>spaceyExpr</code>appears inside a lambda for the current desugaring, it will not be retained and so computed on each invocation of <code>a</code>. However, in the proposed desugaring, the value is retained and shared when the expression is evaluated. This could, of course, lead to surprises in space usage.</p>
<p>It might be argued that do-notation should maintain its current desugaring using <code>Monad</code> and introduce another means by which to perform <code>Applicative</code> desugaring.</p>
<p>Whatever the outcome, all of this distracts from the otherwise glaring oversight.</p>
<h3 id="no">No</h3>
<p>The Functor, Monad, Applicative proposal opens with the following paragraph:</p>
<pre><code>Haskell calls a couple of historical accidents its own. While some of them,
such as the &quot;number classes&quot; hierarchy, can be justified by pragmatism or
lack of a strictly better suggestion, there is one thing that stands out as,
well, not that: Applicative not being a superclass of Monad.</code></pre>
<p>It is my opinion that this proposal is about to commit <em>exactly the same historical mistake</em> that is attempting to be eschewed. Furthermore, by properly eliminating this mistake, the syntax proposal would be improved as a consequence.</p>
<p>Being a strong proponent of progress, and that Haskell is often pushing the front of progress, this makes me a bit sad :(</p>
<p>Fact: not all semigroups are monoids.</p>
<p>No desugaring, current or proposed, utilises the identity value. In the <code>Monad</code> case, this is <code>return</code> and in the <code>Applicative</code> case, this is <code>pure</code>. However, it is a requirement of users to implement these functions. There exist structures that can utilise the full power of this desugaring, but cannot provide the identity value. Therefore, we can eliminate the identity value and still exploit the full advantage of desugaring. Not only this, but it then makes operations available to a strict superset of data types.</p>
<p>Consider the following amendment to the proposal:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Apply</span> f <span class="kw">where</span>
  (<span class="fu">&lt;*&gt;</span>) <span class="ot">::</span>
    f (a <span class="ot">-&gt;</span> b)
    <span class="ot">-&gt;</span> f a
    <span class="ot">-&gt;</span> f b

<span class="kw">class</span> <span class="dt">Apply</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
  pure <span class="ot">::</span>
    a
    <span class="ot">-&gt;</span> f a</code></pre>
<p>We may still derive many of the ubiquitous functions, without the full power of <code>Applicative</code>.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">liftA2 <span class="ot">::</span>
  <span class="dt">Apply</span> f <span class="ot">=&gt;</span>
  (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)
  <span class="ot">-&gt;</span> f a
  <span class="ot">-&gt;</span> f b
  <span class="ot">-&gt;</span> f c
liftA2 f a b <span class="fu">=</span>
  fmap f a <span class="fu">&lt;*&gt;</span> b</code></pre>
<p>We may still exploit our do-notation:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">result <span class="fu">=</span>
  <span class="kw">do</span> a <span class="ot">&lt;-</span> expr1
     b <span class="ot">&lt;-</span> expr2
     return (f a b)

<span class="co">-- apply desugaring</span>
result <span class="fu">=</span>
  fmap f expr1 <span class="fu">&lt;*&gt;</span> expr2</code></pre>
<p>However, more to the point, there are now data structures for which these operations (e.g. <code>liftA2</code>) and do-notation become available, that otherwise would not have been.</p>
<p>Here are some examples of those:</p>
<h5 id="also">Also</h5>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NonEmptyList</span> a <span class="fu">=</span> <span class="dt">NEL</span> a [a]
<span class="kw">data</span> <span class="dt">Also</span> a x <span class="fu">=</span> <span class="dt">Also</span> (<span class="dt">NonEmptyList</span> a) x
<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Also</span> a) <span class="kw">where</span>
<span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">Also</span> a) <span class="kw">where</span>
  <span class="dt">Also</span> (<span class="dt">NEL</span> h t) f <span class="fu">&lt;*&gt;</span> <span class="dt">Also</span> (<span class="dt">NEL</span> h' t') x <span class="fu">=</span>
    <span class="dt">Also</span> (<span class="dt">NEL</span> h (t <span class="fu">++</span> h' <span class="fu">:</span> t')) (f x)</code></pre>
<p>The <code>Also</code> data type has no possible <code>Applicative</code> instance, yet it has a very usable <code>Apply</code>. This means we can use (amended) <code>liftA2</code> and do-notation on <code>Also</code> values, without losing any power.</p>
<p>This data type generalises in fact, while still maintaining an <code>Apply</code> instance.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Also</span> s x <span class="fu">=</span> <span class="dt">Also</span> s x</code></pre>
<p>There is an <code>Apply</code> instance for <code>(Also s)</code> for as long as there is a <code>Semigroup</code> instance for <code>s</code>, however, if your semigroup is not a monoid, then there is no <code>Monoid</code> instance. I have used <code>(NonEmptyList a)</code> as an example of a data type with a semigroup, but not a monoid.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span>
<span class="ot">  (&lt;&gt;) ::</span> <span class="co">-- associative</span>
    a
    <span class="ot">-&gt;</span> a
    <span class="ot">-&gt;</span> a

<span class="kw">instance</span> <span class="dt">Semigroup</span> s <span class="ot">=&gt;</span> <span class="dt">Apply</span> (<span class="dt">Also</span> s) <span class="kw">where</span>
  <span class="dt">Also</span> s1 f <span class="fu">&lt;*&gt;</span> <span class="dt">Also</span> s2 x <span class="fu">=</span>
    <span class="dt">Also</span> (s1 <span class="fu">&lt;&gt;</span> s2) (f x)</code></pre>
<h5 id="ornot">OrNot</h5>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OrNot</span> a <span class="fu">=</span> <span class="co">-- Maybe (NonEmptyList a)</span>
  <span class="dt">Not</span>
  <span class="fu">|</span> <span class="dt">Or</span> (<span class="dt">NonEmptyList</span> a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">OrNot</span> <span class="kw">where</span>

<span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">OrNot</span> <span class="kw">where</span>
  <span class="dt">Not</span> <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span>
    <span class="dt">Not</span>
  <span class="dt">Or</span> _ <span class="fu">&lt;*&gt;</span> <span class="dt">Not</span> <span class="fu">=</span>
    <span class="dt">Not</span>
  <span class="dt">Or</span> (<span class="dt">NEL</span> h t) <span class="fu">&lt;*&gt;</span> <span class="dt">Or</span> (<span class="dt">NEL</span> h' t') <span class="fu">=</span>
    <span class="dt">Or</span> (<span class="dt">NEL</span> (h h') (t <span class="fu">&lt;*&gt;</span> t'))</code></pre>
<p>The <code>OrNot</code> data is isomorphic to <code>Maybe (NonEmptyList a)</code> and has an <code>Apply</code> instance that is similar to the <code>Applicative</code> for <code>Maybe</code>. However, since this data type holds a non-empty list, there is no possibility for an <code>Applicative</code> instance.</p>
<p>Again, with an amended do-notation and library functions, we could use <code>OrNot</code> values.</p>
<h5 id="but-it-doesnt-stop-there">But it doesn’t stop there…</h5>
<p>Your regular old <code>Data.Map#Map</code> can provide an <code>Apply</code> instance, but not an <code>Applicative</code>.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Apply</span> (<span class="dt">Map</span> k) <span class="kw">where</span>
  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span>
    Map.intersectionWith (<span class="fu">$</span>)</code></pre>
<p>There is no corresponding <code>Applicative</code> instance for this <code>Apply</code> instance. This is the same story for <code>Data.IntMap#IntMap</code>.</p>
<p>I want to use <code>liftA2</code> and many other generalised functions on <code>(Map k)</code> values and no, I am not sorry!</p>
<h3 id="apply-not-applicative">Apply not Applicative</h3>
<p>I could go on and on with useful data types that have <code>Apply</code> instances, but no corresponding <code>Applicative</code>. However, I hope this is enough to illustrate the point.</p>
<p>If we are going to amend the type-class hierarchy, taking on all the compatibility issues of doing so, then let us provide a kick-arse solution. It is especially compelling in that this amendment to the proposal subsumes the existing error. Let us move on from yet another historical mistake that <a href="http://hackage.haskell.org/package/semigroupoids">has already been acknowledged</a>.</p>
<h3 id="bind-not-monad">Bind not Monad</h3>
<p>This story is not just about <code>Apply</code> and <code>Applicative</code>. All of the same reasoning applies to semi-monads or the <code>Bind</code> type-class. The <code>return</code> operation is not essential to do-notation or even many monad functions, so it is an unnecessary, imposed requirement for implementers of the <code>Monad</code> type-class.</p>
<p>Similarly, there are structures for which there is a <code>Bind</code> instance, but not a <code>Monad</code> instance.</p>
<h3 id="type-class-hierarchy-proper">Type-class Hierarchy Proper</h3>
<p>In order to take full advantage of a type-class amendment, I submit the following proposed type-class hierarchy. I contend that it subsumes the existing proposal by providing additional flexibility for zero additional loss.</p>
<p>Library functions, such as <code>liftA2</code>, could slowly adopt an amendment to their type signature so as to open up to more data types.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
  fmap <span class="ot">::</span>
    (a <span class="ot">-&gt;</span> b)
    <span class="ot">-&gt;</span> f a
    <span class="ot">-&gt;</span> f b

<span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Apply</span> f <span class="kw">where</span>
  (<span class="fu">&lt;*&gt;</span>) <span class="ot">::</span>
    f (a <span class="ot">-&gt;</span> b)
    <span class="ot">-&gt;</span> f a
    <span class="ot">-&gt;</span> f b

<span class="kw">class</span> <span class="dt">Apply</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
  pure <span class="ot">::</span>
    a
    <span class="ot">-&gt;</span> f a

<span class="kw">class</span> <span class="dt">Apply</span> f <span class="ot">=&gt;</span> <span class="dt">Bind</span> f <span class="kw">where</span>
  (<span class="fu">&gt;&gt;=</span>) <span class="ot">::</span>
    (a <span class="ot">-&gt;</span> f b)
    <span class="ot">-&gt;</span> f a
    <span class="ot">-&gt;</span> f b

<span class="kw">class</span> (<span class="dt">Applicative</span> f, <span class="dt">Bind</span> f) <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></code></pre>
<p>and while we’re at it…</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span>
<span class="ot">  (&lt;&gt;) ::</span> <span class="co">-- mappend</span>
    a
    <span class="ot">-&gt;</span> a
    <span class="ot">-&gt;</span> a

<span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
  mempty <span class="ot">::</span>
    a</code></pre>
<p>but maybe I am biting off a bit too much there :)</p>
<h3 id="addendum-on-pointed">Addendum on Pointed</h3>
<p>I have not mentioned the <code>Pointed</code> experiment, because it is not worth mentioning anymore. It was an experiment, executed in both Scala and Haskell, and the result is conclusive.</p>
<p>However, here is the type-class:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Pointed</span> f <span class="kw">where</span>
  pure <span class="ot">::</span>
    a
    <span class="ot">-&gt;</span> f a</code></pre>
<p>It was once proposed to slot in between <code>Applicative</code> and <code>Functor</code>. The <code>Pointed</code> type-class is not at all useful and there is no value in continuing discussion in this context, but instead about the result of the failed experiment. This is for another day.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There are other functions on <code>Monad</code>, but these are either derivable (e.g. <code>(&gt;&gt;)</code>) or a mistake and hindrance to discussion (e.g. <code>fail</code>).<a href="#fnref1">↩</a></p></li>
</ol>
</div>


<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'tonys--blog';
  var discus_identifier = '/posts/applicative-do/index.html';
  var disqus_url = 'http://blog.tmorris.net/posts/applicative-do/index.html';
  var discus_title = 'Improving Applicative do-notation';
  (function () {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript><p>The comments use <a href="http://disqus.com/?ref_noscript">Disqus</a>,
  which requires Javascript.</p></noscript>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3405112-1']);
  _gaq.push(['_trackPageview']);
  (function () {
    var ga = document.createElement('script');
    ga.type = 'text/javascript';
    ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
