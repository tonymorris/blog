<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>位 Tony's blog 位 - Even Further Understanding scala.Option (part 2)</title>
  <link rel="stylesheet" type="text/css" href="../../css/screen.css" />
  <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
  <link rel="alternate" type="application/atom+xml" href="http://blog.tmorris.net/atom.xml" title="Atom feed" />
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src="https://raw.github.com/Mathapedia/LaTeX2HTML5/master/latex2html5.min.js"></script>
</head>
<body>
<div id="title">
  位 Tony's blog 位
  <div id="subtitle">
    The weblog of Tony Morris
  </div>
</div>
<div id="header">
  <div id="navigation">
    <a href="../../index.html">Home</a>
    <a href="../../posts/">All Posts</a>
    <a href="../../contact/">Contact</a>
    <a href="http://cv.tmorris.net/">CV</a>
    <a href="../../atom.xml"><img src="../../images/feed-icon-14x14.png" alt="feed" /></a>
  </div>
</div>
<h1>Even Further Understanding scala.Option (part 2)</h1>
<div class="info">Posted on September  1, 2010, in <a href="../../tags/Programming/index.html">Programming</a></div>

<p>As a follow-on to <a href="http://blog.tmorris.net/further-understanding-scalaoption/">Further Understanding scala.Option</a>, following are another 10 exercises (numbered 16 to 25). Included are solutions to the original 1 to 15 exercises. Instructions are in the comments.</p>
<pre><code>// Scala version 2.8.0.final
// http://scala-tools.org/repo-releases/org/scala-tools/testing/scalacheck_2.8.0/1.7/scalacheck_2.8.0-1.7.jar</code></pre>
<pre class="sourceCode Scala"><code class="sourceCode scala"><span class="co">/*</span>

<span class="co">  PART 1</span>
<span class="co">  ======</span>
<span class="co">  Below are 15 exercises numbered 1 to 15. The task is to emulate the scala.Option API</span>
<span class="co">  without using Some/None subtypes, but instead using a fold (called a</span>
<span class="co">  catamorphism).</span>

<span class="co">  A couple of functions are already done (map, get)</span>
<span class="co">  to be used as an example. ScalaCheck tests are given below to</span>
<span class="co">  verify the work. The desired result is to have all tests passing.</span>

<span class="co">  The 15th exercise is not available in the existing Scala API so</span>
<span class="co">  instructions are given in the comments.</span>


<span class="co">  Part 2</span>
<span class="co">  ======</span>

<span class="co">  Below are 10 exercises numbered 16 to 25. The task is to implement additional</span>
<span class="co">  methods for the Optional data type. These methods are not provided in the</span>
<span class="co">  scala.Option API so to determine the correct result requires reading the method</span>
<span class="co">  type signature and ensuring that the tests pass.</span>

<span class="co">  The 25th exercise is notable in that its signature says nothing about</span>
<span class="co">  scala.Option yet it is usable for Option (see the test for example).</span>


<span class="co">  Revision History</span>
<span class="co">  ================</span>

<span class="co">  23/08/2010</span>
<span class="co">  * Initial revision</span>

<span class="co">  ----------------</span>

<span class="co">  23/08/2010</span>
<span class="co">  * Fixed prop_getOrElse. Thanks Michael Bayne.</span>

<span class="co">  ----------------</span>

<span class="co">  26/08/2010</span>
<span class="co">  * Add lazy annotation to orElse method.</span>

<span class="co">  ----------------</span>

<span class="co">  01/09/2010</span>
<span class="co">  Added Part 2</span>

<span class="co">  02/09/2010</span>
<span class="co">  * Fixed mapOptionals test (why wasn't it failing?). Thanks Alec Zorab.</span>
<span class="co">  * Added comments including *** special note ***</span>

<span class="co">*/</span>


<span class="kw">trait</span> Optional[A] {
  <span class="co">// single abstract method</span>
  <span class="kw">def</span> fold[X](some: A =&gt; X, none: =&gt; X): X

  <span class="kw">import</span> Optional.<span class="fu">_</span>

  <span class="co">// Done for you.</span>
  <span class="kw">def</span> map[B](f: A =&gt; B): Optional[B] =
    <span class="fu">fold</span>(f andThen some, none[B])

  <span class="co">// Done for you.</span>
  <span class="co">// WARNING: undefined for None</span>
  <span class="kw">def</span> get: A =
    <span class="fu">fold</span>(a =&gt; a, <span class="fu">error</span>(<span class="st">&quot;None.get&quot;</span>))

  <span class="co">// Exercise 1</span>
  <span class="kw">def</span> flatMap[B](f: A =&gt; Optional[B]): Optional[B] =
    <span class="fu">fold</span>(f, none)

  <span class="co">// Exercise 2</span>
  <span class="co">// Rewrite map but use flatMap, not fold.</span>
  <span class="kw">def</span> mapAgain[B](f: A =&gt; B): Optional[B] =
    <span class="fu">flatMap</span>(f andThen some)

  <span class="co">// Exercise 3</span>
  <span class="kw">def</span> <span class="fu">getOrElse</span>(e: =&gt; A): A =
    <span class="fu">fold</span>(s =&gt; s, e)

  <span class="co">// Exercise 4</span>
  <span class="kw">def</span> <span class="fu">filter</span>(p: A =&gt; Boolean): Optional[A] =
    <span class="fu">fold</span>(a =&gt; <span class="kw">if</span>(<span class="fu">p</span>(a)) <span class="fu">some</span>(a) <span class="kw">else</span> none, none)

  <span class="co">// Exercise 5</span>
  <span class="kw">def</span> <span class="fu">exists</span>(p: A =&gt; Boolean): Boolean =
    <span class="fu">fold</span>(p, <span class="kw">false</span>)

  <span class="co">// Exercise 6</span>
  <span class="kw">def</span> <span class="fu">forall</span>(p: A =&gt; Boolean): Boolean =
    <span class="fu">fold</span>(p, <span class="kw">true</span>)

  <span class="co">// Exercise 7</span>
  <span class="kw">def</span> <span class="fu">foreach</span>(f: A =&gt; Unit): Unit =
    <span class="fu">fold</span>(f, ())

  <span class="co">// Exercise 8</span>
  <span class="kw">def</span> isDefined: Boolean =
    <span class="fu">fold</span>(_ =&gt; <span class="kw">true</span>, <span class="kw">false</span>)

  <span class="co">// Exercise 9</span>
  <span class="kw">def</span> isEmpty: Boolean =
    <span class="fu">fold</span>(_ =&gt; <span class="kw">false</span>, <span class="kw">true</span>)

  <span class="co">// Exercise 10</span>
  <span class="kw">def</span> <span class="fu">orElse</span>(o: =&gt; Optional[A]): Optional[A] =
    <span class="fu">fold</span>(_ =&gt; <span class="kw">this</span>, o)

  <span class="co">// Exercise 11</span>
  <span class="kw">def</span> toLeft[X](right: =&gt; X): Either[A, X] =
    <span class="fu">fold</span>(<span class="fu">Left</span>(_), <span class="fu">Right</span>(right))

  <span class="co">// Exercise 12</span>
  <span class="kw">def</span> toRight[X](left: =&gt; X): Either[X, A] =
    <span class="fu">fold</span>(<span class="fu">Right</span>(_), <span class="fu">Left</span>(left))

  <span class="co">// Exercise 13</span>
  <span class="kw">def</span> toList: List[A] =
    <span class="fu">fold</span>(List(_), Nil)

  <span class="co">// Exercise 14</span>
  <span class="kw">def</span> iterator: Iterator[A] =
    <span class="fu">fold</span>(Iterator.<span class="fu">single</span>(_), Iterator.<span class="fu">empty</span>)

  <span class="co">// Exercise 15 The Clincher!</span>
  <span class="co">// Return a none value if either this or the argument is none.</span>
  <span class="co">// Otherwise apply the function to the argument in some.</span>
  <span class="co">// Don't be afraid to use functions you have written.</span>
  <span class="co">// Better style, more points!</span>
  <span class="kw">def</span> applic[B](f: Optional[A =&gt; B]): Optional[B] =
    f flatMap map

  <span class="co">// Utility</span>
  <span class="kw">def</span> toOption: Option[A] = <span class="fu">fold</span>(Some(_), None)

  <span class="co">// Utility</span>
  <span class="kw">override</span> <span class="kw">def</span> toString =
    <span class="fu">fold</span>(<span class="st">&quot;some[&quot;</span> + _ + <span class="st">&quot;]&quot;</span>, <span class="st">&quot;none&quot;</span>)

  <span class="co">// Utility</span>
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">equals</span>(o: Any) =
    o.<span class="fu">isInstanceOf</span>[Optional[_]] &amp;&amp; {
      <span class="kw">val</span> q = o.<span class="fu">asInstanceOf</span>[Optional[_]]
      <span class="fu">fold</span>(a =&gt; q.<span class="fu">exists</span>(a == _),
           q.<span class="fu">isEmpty</span>)
    }
}

<span class="kw">object</span> Optional {
  <span class="co">// Done for you</span>
  <span class="kw">def</span> none[A]: Optional[A] = <span class="kw">new</span> Optional[A] {
    <span class="kw">def</span> fold[X](some: A =&gt; X, none: =&gt; X) = none
  }

  <span class="co">// Done for you</span>
  <span class="kw">def</span> some[A](a: A): Optional[A] = <span class="kw">new</span> Optional[A] {
    <span class="kw">def</span> fold[X](some: A =&gt; X, none: =&gt; X) = <span class="fu">some</span>(a)
  }

  <span class="co">// Utility</span>
  <span class="kw">def</span> fromOption[A](o: Option[A]): Optional[A] = o <span class="kw">match</span> {
    <span class="kw">case</span> None    =&gt; none
    <span class="kw">case</span> Some(a) =&gt; <span class="fu">some</span>(a)
  }

  <span class="co">// *** Special note ***</span>
  <span class="co">// Some of these functions are likely to be familiar List functions,</span>
  <span class="co">// but with one specific distinction: in every covariant value appearing in</span>
  <span class="co">// the type signature, this value is wrapped in Optional.</span>
  <span class="co">// For example, the unwrapped:</span>
  <span class="co">// filter:          (A =&gt; Boolean) =&gt; List[A] =&gt; List[A]</span>
  <span class="co">// and the wrapped:</span>
  <span class="co">// filterOptionals: (A =&gt; Optional[Boolean]) =&gt; List[A] =&gt; Optional[List[A]]</span>
  <span class="co">//</span>
  <span class="co">// There are other functions of a similar nature below.</span>

  <span class="co">// Exercise 16</span>
  <span class="co">// If a none is encountered, then return a none, otherwise,</span>
  <span class="co">// accumulate all the values in Optional.</span>
  <span class="kw">def</span> mapOptionals[A, B](f: A =&gt; Optional[B], a: List[A]): Optional[List[B]] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)

  <span class="co">// Exercise 17</span>
  <span class="co">// If a none is encountered, then return a none, otherwise,</span>
  <span class="co">// accumulate all the values in Optional.</span>
  <span class="kw">def</span> sequenceOptionals[A](a: List[Optional[A]]): Optional[List[A]] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)

  <span class="co">// Exercise 18</span>
  <span class="co">// Use sequenceOptionals</span>
  <span class="kw">def</span> mapOptionalsAgain[A, B](f: A =&gt; Optional[B], a: List[A]): Optional[List[B]] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)

  <span class="co">// Exercise 19</span>
  <span class="co">// Use mapOptionals</span>
  <span class="kw">def</span> sequenceOptionalsAgain[A](a: List[Optional[A]]): Optional[List[A]] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)

  <span class="co">// Exercise 20</span>
  <span class="co">// If a none is encountered, return none, otherwise,</span>
  <span class="co">// flatten/join by one level.</span>
  <span class="kw">def</span> joinOptionals[A](a: Optional[Optional[A]]): Optional[A] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)

  <span class="co">// Exercise 21</span>
  <span class="kw">def</span> filterOptionals[A](p: A =&gt; Optional[Boolean], a: List[A]): Optional[List[A]] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)

  <span class="co">// Exercise 22</span>
  <span class="kw">def</span> fillOptionals[A](n: Int, a: Optional[A]): Optional[List[A]] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)

  <span class="co">// Exercise 23</span>
  <span class="co">// Use sequenceOptionals</span>
  <span class="kw">def</span> fillOptionalsAgain[A](n: Int, a: Optional[A]): Optional[List[A]] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)

  <span class="co">// Exercise 24</span>
  <span class="co">// Methods mentioning Optional in the type signature are prohibited, except applic and map</span>
  <span class="kw">def</span> mapOptionalsYetAgain[A, B](f: A =&gt; Optional[B], a: List[A]): Optional[List[B]] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)

  <span class="co">// Consider: def joinOptional[A](a: Optional[Optional[A]]): Optional[A]</span>
  <span class="co">// This function &quot;flattens&quot; the Optional into a Some value if possible.</span>
  <span class="co">// It is not possible to write this using only applic and map (try it!).</span>

  <span class="co">// Bye bye Option-specificity!</span>
  <span class="co">// (setting up for Exercise 25)</span>
  <span class="kw">trait</span> Applic[F[_]] {
    <span class="kw">def</span> point[A](a: A): F[A]
    <span class="kw">def</span> applic[A, B](f: F[A =&gt; B], a: F[A]): F[B]

    <span class="kw">final</span> <span class="kw">def</span> map[A, B](f: A =&gt; B, a: F[A]): F[B] =
      <span class="fu">applic</span>(<span class="fu">point</span>(f), a)
  }

  <span class="kw">object</span> Applic {
    <span class="kw">implicit</span> <span class="kw">val</span> OptionalApplic: Applic[Optional] = <span class="kw">new</span> Applic[Optional] {
      <span class="kw">def</span> point[A](a: A): Optional[A] = <span class="fu">some</span>(a)
      <span class="kw">def</span> applic[A, B](f: Optional[A =&gt; B], a: Optional[A]): Optional[B] = a applic f
    }
  }

  <span class="co">// Exercise 25</span>
  <span class="co">// The Double-Clincher!</span>
  <span class="kw">def</span> mapWhatever[A, B, F[_]](f: A =&gt; F[B], a: List[A])(<span class="kw">implicit</span> z: Applic[F]): F[List[B]] =
    <span class="fu">error</span>(<span class="st">&quot;todo&quot;</span>)
}

<span class="kw">import</span> org.<span class="fu">scalacheck</span>.<span class="fu">_</span>
<span class="kw">import</span> Arbitrary.<span class="fu">arbitrary</span>
<span class="kw">import</span> Prop.<span class="fu">_</span>

<span class="kw">object</span> TestOptional <span class="kw">extends</span> Properties(<span class="st">&quot;Optional&quot;</span>) {
  <span class="kw">import</span> Optional.<span class="fu">_</span>

  <span class="kw">implicit</span> <span class="kw">def</span> ArbitraryOptional[A](<span class="kw">implicit</span> a: Arbitrary[A]): Arbitrary[Optional[A]] =
    <span class="fu">Arbitrary</span>(arbitrary[Option[A]] map fromOption)

  <span class="fu">property</span>(<span class="st">&quot;map&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], f: Int =&gt; String) =&gt;
    (o map f).<span class="fu">toOption</span> == (o.<span class="fu">toOption</span> map f))

  <span class="fu">property</span>(<span class="st">&quot;get&quot;</span>) = <span class="fu">forAll</span>((o: Optional[Int]) =&gt;
    o.<span class="fu">isDefined</span> ==&gt;
      (o.<span class="fu">get</span> == o.<span class="fu">toOption</span>.<span class="fu">get</span>))

  <span class="fu">property</span>(<span class="st">&quot;flatMap&quot;</span>) = <span class="fu">forAll</span>((o: Optional[Int], f: Int =&gt; Optional[String]) =&gt;
    (o flatMap f).<span class="fu">toOption</span> == (o.<span class="fu">toOption</span> <span class="fu">flatMap</span> (<span class="fu">f</span>(_).<span class="fu">toOption</span>)))

  <span class="fu">property</span>(<span class="st">&quot;mapAgain&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], f: Int =&gt; String) =&gt;
    (o mapAgain f).<span class="fu">toOption</span> == (o map f).<span class="fu">toOption</span>)

  <span class="fu">property</span>(<span class="st">&quot;getOrElse&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], n: Int) =&gt;
    (o getOrElse n) == (o.<span class="fu">toOption</span> getOrElse n))

  <span class="fu">property</span>(<span class="st">&quot;filter&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], f: Int =&gt; Boolean) =&gt;
    (o filter f).<span class="fu">toOption</span> == (o.<span class="fu">toOption</span> filter f))

  <span class="fu">property</span>(<span class="st">&quot;exists&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], f: Int =&gt; Boolean) =&gt;
    (o exists f) == (o.<span class="fu">toOption</span> exists f))

  <span class="fu">property</span>(<span class="st">&quot;forall&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], f: Int =&gt; Boolean) =&gt;
    (o forall f) == (o.<span class="fu">toOption</span> forall f))

  <span class="fu">property</span>(<span class="st">&quot;foreach&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], f: Int =&gt; Unit, n: Int) =&gt; {
    <span class="kw">var</span> x: Int = n
    <span class="kw">var</span> y: Int = x

    o <span class="fu">foreach</span> (t =&gt; x = x + t)
    o.<span class="fu">toOption</span> <span class="fu">foreach</span> (t =&gt; y = y + t)

    x == y
  })

  <span class="fu">property</span>(<span class="st">&quot;isDefined&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int]) =&gt;
    (o.<span class="fu">isDefined</span>) == (o.<span class="fu">toOption</span>.<span class="fu">isDefined</span>))

  <span class="fu">property</span>(<span class="st">&quot;isEmpty&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int]) =&gt;
    o.<span class="fu">isEmpty</span> == o.<span class="fu">toOption</span>.<span class="fu">isEmpty</span>)

  <span class="fu">property</span>(<span class="st">&quot;orElse&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], p: Optional[Int]) =&gt;
    (o orElse p).<span class="fu">toOption</span> == (o.<span class="fu">toOption</span> orElse p.<span class="fu">toOption</span>))

  <span class="fu">property</span>(<span class="st">&quot;toLeft&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], n: Int) =&gt;
    (o toLeft n) == (o.<span class="fu">toOption</span> toLeft n))

  <span class="fu">property</span>(<span class="st">&quot;toRight&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int], n: Int) =&gt;
    (o toRight n) == (o.<span class="fu">toOption</span> toRight n))

  <span class="fu">property</span>(<span class="st">&quot;toList&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int]) =&gt;
    o.<span class="fu">toList</span> == o.<span class="fu">toOption</span>.<span class="fu">toList</span>)

  <span class="fu">property</span>(<span class="st">&quot;iterator&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int]) =&gt;
    o.<span class="fu">iterator</span> sameElements o.<span class="fu">toOption</span>.<span class="fu">iterator</span>)

  <span class="co">// *** READ THIS COMMENT FIRST ***</span>
  <span class="co">// Note that scala.Option has no such equivalent to this method</span>
  <span class="co">// Therefore, reading this test may give away clues to how it might be solved.</span>
  <span class="co">// If you do not wish to spoil it, look away now and follow the</span>
  <span class="co">// instruction in the Exercise comment.</span>
  <span class="fu">property</span>(<span class="st">&quot;applic&quot;</span>) = <span class="fu">forAll</span> ((o: Optional[Int =&gt; String], p: Optional[Int]) =&gt;
    (p applic o).<span class="fu">toOption</span> ==
    (<span class="kw">for</span>(f &lt;- o.<span class="fu">toOption</span>;
         n &lt;- p.<span class="fu">toOption</span>)
    <span class="kw">yield</span> <span class="fu">f</span>(n)))

  <span class="kw">def</span> trace[A](a: A) = {
    <span class="fu">println</span>(a)
    a
  }

  <span class="fu">property</span>(<span class="st">&quot;mapOptionals&quot;</span>) = <span class="fu">forAll</span>((f: Int =&gt; Optional[String], o: List[Int]) =&gt;
  {
    <span class="kw">val</span> i = o map f
    <span class="fu">mapOptionals</span>(f, o) == (<span class="kw">if</span>(i <span class="fu">forall</span> (_.<span class="fu">isDefined</span>)) <span class="fu">some</span>(i <span class="fu">map</span> (_.<span class="fu">get</span>)) <span class="kw">else</span> none)
  })

  <span class="fu">property</span>(<span class="st">&quot;sequenceOptionals&quot;</span>) = <span class="fu">forAll</span>((o: List[Optional[String]]) =&gt;
      <span class="fu">sequenceOptionals</span>(o) == (<span class="kw">if</span>(o <span class="fu">exists</span> (_.<span class="fu">isEmpty</span>)) none <span class="kw">else</span> <span class="fu">some</span>(o <span class="fu">map</span> (_.<span class="fu">get</span>))))

  <span class="fu">property</span>(<span class="st">&quot;mapOptionalsAgain&quot;</span>) = <span class="fu">forAll</span>((f: Int =&gt; Optional[String], o: List[Int]) =&gt;
      <span class="fu">mapOptionalsAgain</span>(f, o) == <span class="fu">mapOptionals</span>(f, o))

  <span class="fu">property</span>(<span class="st">&quot;sequenceOptionalsAgain&quot;</span>) = <span class="fu">forAll</span>((o: List[Optional[String]]) =&gt;
      <span class="fu">sequenceOptionalsAgain</span>(o) == <span class="fu">sequenceOptionals</span>(o))

  <span class="fu">property</span>(<span class="st">&quot;joinOptionals&quot;</span>) = <span class="fu">forAll</span>((o: Optional[Optional[String]]) =&gt;
      <span class="fu">joinOptionals</span>(o) == (<span class="kw">if</span>(o.<span class="fu">isDefined</span> &amp;&amp; o.<span class="fu">get</span>.<span class="fu">isDefined</span>) o.<span class="fu">get</span> <span class="kw">else</span> none))

  <span class="fu">property</span>(<span class="st">&quot;filterOptionals&quot;</span>) = <span class="fu">forAll</span>((f: Int =&gt; Optional[Boolean], o: List[Int]) =&gt;
      <span class="fu">filterOptionals</span>(f, o) == (<span class="kw">if</span>(o <span class="fu">exists</span> (<span class="fu">f</span>(_).<span class="fu">isEmpty</span>)) none <span class="kw">else</span> <span class="fu">some</span>(o <span class="fu">filter</span> (<span class="fu">f</span>(_).<span class="fu">get</span>))))

  <span class="fu">property</span>(<span class="st">&quot;fillOptionals&quot;</span>) = <span class="fu">forAll</span>((n: Int, o: Optional[String]) =&gt;
      (n &lt; <span class="dv">1000</span>) ==&gt; <span class="co">// prevent stack consumption</span>
      (<span class="fu">fillOptionals</span>(n, o) == (<span class="kw">if</span>(n &lt;= <span class="dv">0</span>) <span class="fu">some</span>(Nil) <span class="kw">else</span> (o <span class="fu">map</span> (List.<span class="fu">fill</span>(n)(_))))))

  <span class="fu">property</span>(<span class="st">&quot;fillOptionalsAgain&quot;</span>) = <span class="fu">forAll</span>((n: Int, o: Optional[String]) =&gt;
      (n &lt; <span class="dv">1000</span>) ==&gt; <span class="co">// prevent stack consumption</span>
      (<span class="fu">fillOptionalsAgain</span>(n, o) == <span class="fu">fillOptionals</span>(n, o)))

  <span class="fu">property</span>(<span class="st">&quot;mapOptionalsYetAgain&quot;</span>) = <span class="fu">forAll</span>((f: Int =&gt; Optional[String], o: List[Int]) =&gt;
      <span class="fu">mapOptionalsYetAgain</span>(f, o) == <span class="fu">mapOptionals</span>(f, o))

  <span class="fu">property</span>(<span class="st">&quot;mapWhatever&quot;</span>) = <span class="fu">forAll</span>((f: Int =&gt; Optional[String], o: List[Int]) =&gt;
      <span class="fu">mapWhatever</span>(f, o) == <span class="fu">mapOptionals</span>(f, o))

  <span class="co">/*</span>
<span class="co">  $ scala -classpath .:scalacheck_2.8.0-1.7.jar TestOptional</span>
<span class="co">  + Optional.map: OK, passed 100 tests.</span>
<span class="co">  + Optional.get: OK, passed 100 tests.</span>
<span class="co">  + Optional.flatMap: OK, passed 100 tests.</span>
<span class="co">  + Optional.mapAgain: OK, passed 100 tests.</span>
<span class="co">  + Optional.getOrElse: OK, passed 100 tests.</span>
<span class="co">  + Optional.filter: OK, passed 100 tests.</span>
<span class="co">  + Optional.exists: OK, passed 100 tests.</span>
<span class="co">  + Optional.forall: OK, passed 100 tests.</span>
<span class="co">  + Optional.foreach: OK, passed 100 tests.</span>
<span class="co">  + Optional.isDefined: OK, passed 100 tests.</span>
<span class="co">  + Optional.isEmpty: OK, passed 100 tests.</span>
<span class="co">  + Optional.orElse: OK, passed 100 tests.</span>
<span class="co">  + Optional.toLeft: OK, passed 100 tests.</span>
<span class="co">  + Optional.toRight: OK, passed 100 tests.</span>
<span class="co">  + Optional.toList: OK, passed 100 tests.</span>
<span class="co">  + Optional.iterator: OK, passed 100 tests.</span>
<span class="co">  + Optional.applic: OK, passed 100 tests.</span>
<span class="co">  + Optional.mapOptionals: OK, passed 100 tests.</span>
<span class="co">  + Optional.sequenceOptionals: OK, passed 100 tests.</span>
<span class="co">  + Optional.mapOptionalsAgain: OK, passed 100 tests.</span>
<span class="co">  + Optional.sequenceOptionalsAgain: OK, passed 100 tests.</span>
<span class="co">  + Optional.joinOptionals: OK, passed 100 tests.</span>
<span class="co">  + Optional.filterOptionals: OK, passed 100 tests.</span>
<span class="co">  + Optional.fillOptionals: OK, passed 100 tests.</span>
<span class="co">  + Optional.fillOptionalsAgain: OK, passed 100 tests.</span>
<span class="co">  + Optional.mapOptionalsYetAgain: OK, passed 100 tests.</span>
<span class="co">  + Optional.mapWhatever: OK, passed 100 tests.</span>
<span class="co">  */</span>
}</code></pre>


<hr />
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'tonys--blog';
  var discus_identifier = '/posts/even-further-understanding-scalaoption-part-2/index.html';
  var disqus_url = 'http://blog.tmorris.net/posts/even-further-understanding-scalaoption-part-2/index.html';
  var discus_title = 'Even Further Understanding scala.Option (part 2)';
  (function () {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript><p>The comments use <a href="http://disqus.com/?ref_noscript">Disqus</a>,
  which requires Javascript.</p></noscript>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3405112-1']);
  _gaq.push(['_trackPageview']);
  (function () {
    var ga = document.createElement('script');
    ga.type = 'text/javascript';
    ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
