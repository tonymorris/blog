<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>λ Tony's blog λ — Posts tagged Haskell</title>
    <link href="http://blog.tmorris.net/tags/Haskell.xml" rel="self" />
    <link href="http://blog.tmorris.net" />
    <id>http://blog.tmorris.net/tags/Haskell.xml</id>
    <author>
        <name>Tony Morris</name>
        <email>blog@tmorris.net</email>
    </author>
    <updated>2014-06-04T00:00:00Z</updated>
    <entry>
    <title>What kind of things are easy in Haskell and hard in Scala, and vice-versa?</title>
    <link href="http://blog.tmorris.net/posts/what-kind-of-things-are-easy-in-haskell-and-hard-in-scala-and-vice-versa/index.html" />
    <id>http://blog.tmorris.net/posts/what-kind-of-things-are-easy-in-haskell-and-hard-in-scala-and-vice-versa/index.html</id>
    <published>2014-06-04T00:00:00Z</published>
    <updated>2014-06-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>On 24 February 2011, Daniel C. Sobral writes:</em></p>
<p>There has been some intermingling of Scala and Haskell communities, and I have noticed now and then people commenting on stuff that’s supposed to be easy in Haskell and hard and Scala. Less often (maybe because I read Scala questions, not Haskell ones), I see someone mentioning that something in Scala is easier than in Haskell.</p>
<p>So. I’d like to know from people who are knowledgeable in both what kind of things are easy in Haskell and hard in Scala, and, conversely, what kind of things are easy in Scala and hard in Haskell.</p>
<hr />
<p><em>Tony Morris responds 9 hours later:</em></p>
<p>Daniel, As you know my day job is primarily writing Haskell and secondarily Scala. I have also used both languages for teaching, though not in universities (I use other languages there), but mostly for voluntary teaching that I still do today. Very rarely, I use Java or Javascript. I work for a product company.</p>
<p>I am pleased to see that my prediction is false – your question has not provoked a slew of misinformation as I thought it would. As a result, I am compelled not to ignore it :) So here goes.</p>
<p>At a somewhat superficial level, Haskell has significantly superior tool support over Scala and Java. For non-exhaustive example, Haskell has hoogle, djinn and pl; three tools that alone are extremely useful for which there is no equivalent for Scala. These tools exist and are as useful as they are, because of certain fundamental properties of Haskell itself. Here I mean, the hoogle function is only as useful as it is because Haskell tags IO effects in the type delineating values with types IO t and t, so hoogling for say, [a] -&gt; Int eliminates a lot of candidate functions that would have this type in other environments. In Scala, without the delineation between an Int that has been computed with its arguments, and an Int that has been computed with the entire universe, a hoogle-equivalent would not be as useful – nevertheless, it would be somewhat useful were it to exist.</p>
<p>Haskell’s hlint is also superior to say, Java’s CheckStyle. Included in GHC is a warning system, which when coupled with hlint is far more comprehensive. I’ve not seen anything like this for Scala.</p>
<p>Haskell has cleaner syntax and superior type inference. Very rarely is it the case that we must type-annotate our Haskell. This is not to say that we do not type-annotate our Haskell, just that we have the choice. As you know, this is not so with Scala. However, on an extremely superficial level, I prefer Scala’s lambda syntax to Haskell’s, which requires a pseudo-lambda symbol (). In any case, I aim for point-free style where appropriate, making this already-weak point moot. I use Haskell’s clean syntax to appeal to children in the challenges of teaching. Children take very easily to Haskell’s syntax, since there is far less redundant, “off to the side”, “let’s take a little excursion to nowhere”, ceremony (so to speak). As you might guess, children are easily distracted – Haskell helps me as a teacher to keep this in check.</p>
<p>On to the fundamentals. As you know, Haskell is call-by-need by default, where Scala is the other way around. This is, of course, a very contentious issue. Nevertheless, I admit to falling very strongly to one side: call-by-need by default is the most practical and Scala’s evaluation model is a very far-away second place. I have never seen a legitimate argument that comes close to swaying my position on this, though I do invite it (not here please). To summarise, I think Haskell has a superior evaluation model. There are also nuances in Scala’s laziness. For example, while Scala unifies lazy values, it does not do so for those in contravariant position. i.e. a (Int =&gt; Int) is not a ((=&gt; Int) =&gt; Int).</p>
<p>This contentious issue aside, Haskell’s effect-tracking (by the way, which is a consequence of its evaluation model), is overwhelmingly practical to every-day software tasks. The absence of same or similar is quite devastating as many users of Scala have become aware (by wishing for a solution). I cannot emphasise how important this form of static type-check is to typical business programming in terse form, so I won’t try here.</p>
<p>Haskell has far superior library support than Scala and Java. You and I have discussed this before. Scala lacks some of the most fundamental functions in its standard libraries and the higher-level ones are even more scarce. For example, there are fundamental properties of Scala making good library support more difficult (strict evaluation, Java interop), however, neither of these incur such a penalty as to produce what can only be described as an unfortunate catastrophe as the Scala standard libraries. That is to say, the Scala standard libraries could easily be miles ahead of where they are today, but they are not and you (I) are left with ponderances as to why – something about third lumbar vertebrae and expert levels or something I suppose.</p>
<p>To help emphasise this point, there are times in my day job when I come off a project from using Haskell to Scala. This comes with some consequences that I feel immediately with a very sharp contrast; I then use intellij idea which is slow, cumbersome and full of bugs, the Scala type inferencer is less robust and difficult to prototype with (I may make a type-error and it all just carries on as if nothing happened), but there is nothing more disappointing than having to spend (waste) a few hours implementing a library that really should already be there – what a waste of my time and probably the next guy who has to implement such fundamental library abilities. Talk about shaving yaks. In my opinion, this is the most disappointing part of Scala, especially since there is nothing stopping it from having a useful library besides skill and absence of ability to recognise what a useful library even is. This happens for Haskell too, but to a far lesser extent. I digress in frustration.</p>
<p>The GHC REPL (GHCi) has better support for every-day programming. More useful tab-completion, :type, :info and :browse commands are heavily missed when in Scala. It’s also much faster, but Scala can be forgiven given the JVM.</p>
<p>Why use Scala? I can call the Java APIs, even the most ridiculous, yet popular, APIs ever written. I can call WebSphere methods and I can write servlets. I can write a Wicket application, or use the Play framework or I can do something outragoeus with a database and hibernate. I can do all those things that our industry seems to think are useful, though I secretly contend are pathetic, and I hope our children do too. I can completely avoid the arguments and discussions associated with the merits of these issues, and get on with the job, while still getting the benefits of a language that is vastly superior to Java. This might seem like a cheap stab, though I am sincere when I say that is a true benefit that I value a lot.</p>
<p>Scala’s module system is superior to Haskell’s, almost. That is, it has some things that are very useful that Haskell does not, but also vice versa – for example, Haskell allows a module to export other modules. Scala requires you to stick your finger in your left ear to do this; oh and intellij idea stops working – I exaggerate, but you get the point. Scala has package objects and and first-class module niceties. Haskell lacks here.</p>
<p>Scala also has the ability to namespace a function by giving special status to one of its arguments (some people call this OO, then don’t, in the very next breath – I never get it). What I mean is, you may have two functions with the same name, which are disambiguated at the call site by the type of the argument to the left of the dot. I am deliberately not calling this by any special name, but rather focussing on its utility – Haskell can do this with qualified imports – not quite so nice. I am usually, though not always, particularly unimaginative when it comes to inventing function names – allowing me to reuse one without a penalty is very handy indeed. Note here I do not mean overloading – I think the Scala community has worked out that overloading is just not worth it – do not do it, ever.</p>
<p>In my experiences, Scala appeals to existing programmers, who can usually get up and running quicker than with Haskell. In contrast, non-programmers get up and running with Haskell far quicker than with Scala. As a teacher, I used to think this was a great attribute of Scala, then I tried it, then I thought it was just good. Today, I think it is just not worth it – I have seen too many catastrophes when programmers who are familiar with degenerate problem-solving techniques (ala Java) are handed such things as Scala. Call me pessimistic or some-such, but I wish to remind you that a few years ago, I was handed an already-failed project written in Scala by the Java guys, which I was supposed to “save” because I was the “Scala expert.” I’m sure you can guess how that turned out. I have many (many) anecdotes like this, though most of those are confirmed each time I try to use Scala for teaching existing programmers, rather than in industry (perhaps this is my selection bias, given my extreme apprehension). Nevertheless, my experiences aside, you may call this a benefit over Haskell – there is no doubting that existing programmers get up and running much quicker with Scala.</p>
<p>I can think of a few other tid-bits, but hopefully this satisfies your curiosity. I don’t know how many people are in my position of using both languages extensively in a commercial environment, but I’d truly love to hear from someone who does – especially if they take strong objection to my opinions. That is to say, I invite (and truly yearn for) well-informed peer review of these opinions.</p>
<p>Hope this helps.</p>
<hr />
<p><em>Recovered from <a href="http://www.stackprinter.com/export?service=programmers.stackexchange&amp;question=51245&amp;printer=false&amp;linktohome=true">StackPrinter</a> after deletion and much subsequent searching.</em></p>]]></summary>
</entry>
<entry>
    <title>Haskell Functions Take One Argument</title>
    <link href="http://blog.tmorris.net/posts/haskell-functions-take-one-argument/index.html" />
    <id>http://blog.tmorris.net/posts/haskell-functions-take-one-argument/index.html</id>
    <published>2014-03-04T08:00:00Z</published>
    <updated>2014-03-04T08:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I teach functional programming. It is a significant part of my job. I enjoy it a lot and it is extremely challenging; in my opinion, much more so than learning functional programming itself.</p>
<p>I use the Haskell programming language for teaching functional programming. I like to emphasise the learning and construction of <em>concepts</em> over learning the details of any specific programming language. I am not into teaching programming languages; I really find that boring, uneventful and unhelpful for all involved. However, learning some of the intricacies of Haskell itself is inevitable. It doesn’t take long though and is very much worth the investment of effort if you aspire to learning concepts.</p>
<p>That is to say, using (almost all) other programming languages for this objective is a false economy that is not even a close call. One could spent many weeks or even years demanding to articulate concepts in a specific programming language, only to struggle precisely because that language resists an accurate expression and formation of that concept. I have seen this an overwhelming number of times. It is often supported by the fallacy of false compromise, “but all languages are Turing-complete, so I am going to use JavaScript, which even has first-class functions, in order to come to understand what monad means.”</p>
<p>No, you won’t, I absolutely insist and promise.</p>
<p>This is all somewhat beside the point of this post though. The point is that there is a fact, which often comes up in teaching, that can be expressed briefly and concisely. It requires no exceptions, apologies or approximations. I would like to state this fact and explain some of the nomenclature that surrounds this fact.</p>
<blockquote>
<p>All functions in the Haskell programming language take exactly one argument.</p>
</blockquote>
<p>This fact is certain to come up early on in teaching. If a student comes to trust then follow this fact, then progress will be unhindered. That is because it is an absolute fact. However, even though a student may initially convince themselves of this fact, it has been my experience that they will renege on it at some time in the future.</p>
<p>The use of casual terminology such as the following surely helps to set this trap:</p>
<blockquote>
<p>Examining the signature to the <code>map</code> function, we see that it takes <em>two arguments</em>:</p>
</blockquote>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b</code></pre>
<p>We will then talk about the <em>first argument</em> and the <em>second argument</em> as if there even is such a thing.</p>
<p>However, the truth of the original fact has not changed. Look at it, just sitting there, saying nothing, being all shiny and true. So how could all functions take one argument, while we simultaneously and casually talk about a “second argument”? Are we just telling great big lies? Have we made a mistake?</p>
<p>The problem is our vocabulary. In our spoken words, we are using an <strong>approximation</strong> of fact and superficially, it looks like a blatant contradiction. Let us expand our approximation to more obviously coincide with our statement of fact. I have added some annotation in [brackets].</p>
<blockquote>
<p>Examining the signature to the <code>map</code> function, we see that it is a function [therefore, it definitely takes one argument]. That argument is of the type <code>(a -&gt; b)</code> [which is also a function]. The return type of the <code>map</code> function is <code>(List a -&gt; List b)</code> which is a function and [since it is a function] takes one argument. That argument is of the type <code>(List a)</code> and it returns a value [not a function]. That value is of the type <code>List b</code>.</p>
</blockquote>
<p>When we say out loud “the <code>map</code> function takes two arguments”, we are approximating for the above expansion. It is important to understand what we really mean here.</p>
<p>During my teaching, I will often make a deal with students; I will use the terser vocabulary with you and I will even let you use it, however, if at any moment you violate our understanding of its proper meaning, I will rip it out from under you and demand that you use the full expansion. Almost always, the student will agree to this deal.</p>
<p>Some time after having made this deal, I will hear the following question. Given, for example, this solution to an exercise:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">flatten <span class="ot">::</span>
  <span class="dt">List</span> (<span class="dt">List</span> a)
  <span class="ot">-&gt;</span> <span class="dt">List</span> a
flatten <span class="fu">=</span>
  foldRight (<span class="fu">++</span>) <span class="dt">Nil</span></code></pre>
<p>I will hear this question:</p>
<blockquote>
<p>Wait a minute, you only passed two arguments to <code>foldRight</code>, however, we have seen that it takes three. How could this possibly work!?</p>
</blockquote>
<p>Here is another example of the question. Given this solution:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">filter <span class="ot">::</span>
  (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  <span class="ot">-&gt;</span> <span class="dt">List</span> a
  <span class="ot">-&gt;</span> <span class="dt">List</span> a
filter f <span class="fu">=</span>
  foldRight (\a <span class="ot">-&gt;</span> <span class="kw">if</span> f a <span class="kw">then</span> (a<span class="fu">:.</span>) <span class="kw">else</span> id) <span class="dt">Nil</span></code></pre>
<p>I will hear this question:</p>
<blockquote>
<p>The argument to <code>foldRight</code> (which is itself a function) takes two arguments, however, the function you passed to <code>foldRight</code> has been specified to take only one (which you have called <code>a</code>). How could this even work?</p>
</blockquote>
<p>It is at this moment that I hand out an infringement notice under our agreed penal code for the offence of:</p>
<pre><code>Section 1.1
Failure to Accept that All Haskell Functions Take One Argument

Penalty
Temporary Incarceration at Square One with release at the discretion of an
appointed Probation Officer</code></pre>
<p>I understand that in a learning environment, it may be easy to demonstrate and subsequently accept this fact, then later fall afoul when previously learned facts interfere with this most recent one. The purpose of going back to square one and starting again is to properly internalise this fact. It is an important one, not just for the Haskell programming language, but for Functional Programming in general.</p>
<p>Joking aside, the purpose of this post is to help reconcile these observations. There is a recipe to disentanglement. If you find yourself in this situation, follow these steps:</p>
<ol style="list-style-type: decimal">
<li>Revert back to the fact of matter; all Haskell functions always take one argument. There is never an exception to this rule (so you cannot possibly be observing one!).</li>
<li>From this starting position, reason about your observations with this fact in mind, even if it is a little clumsy at first. After some repetitions, this clumsiness will disappear. Persevere with it for now.</li>
<li>Introspect on the thought process that led you into that trap to begin with. This will help you in the future as you begin to trust that principled thinking will resolve these kinds of conflicts. It can be initially clumsy, even to the point of resisting on that basis, but that is a one-time penalty which quickly speeds up.</li>
</ol>
<p>Hope this helps.</p>]]></summary>
</entry>
<entry>
    <title>Improving Applicative do-notation</title>
    <link href="http://blog.tmorris.net/posts/applicative-do/index.html" />
    <id>http://blog.tmorris.net/posts/applicative-do/index.html</id>
    <published>2013-10-18T20:00:00Z</published>
    <updated>2013-10-18T20:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="monad-and-functor">Monad and Functor</h3>
<p>The <a href="http://haskell.org/">Haskell programming language</a> has a <code>Monad</code> type-class as well as a <code>Functor</code> type-class. It is possible to derive the <code>Functor</code> primitive (<code>fmap</code>) from the <code>Monad</code> primitives:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- derive fmap from the Monad primitives, (&gt;&gt;=) and return</span>
fmap f x <span class="fu">=</span>
  x <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> f</code></pre>
<p>Therefore, it is reasonably argued that <code>Monad</code> should extend <code>Functor</code> so as to provide this default definition of <code>fmap</code>. Due to history, this is not the case, which leads to some awkward situations.</p>
<p>For example, since not all <code>Functor</code> instances are <code>Monad</code> instances, a given operation may wish to restrict itself (if possible) to <code>Functor</code> so that it can be used against those data types. In short, use <code>fmap</code> instead of <code>liftM</code> to prevent an unnecessary constraint on the type of the operation.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">fFlip <span class="ot">::</span>
  <span class="dt">Functor</span> f <span class="ot">=&gt;</span>
  f (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> a
  <span class="ot">-&gt;</span> f b
fFlip f a <span class="fu">=</span>
  fmap (<span class="fu">$</span>a) f

mFlip <span class="ot">::</span>
  <span class="dt">Monad</span> f <span class="ot">=&gt;</span>
  f (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> a
  <span class="ot">-&gt;</span> f b
mFlip f a <span class="fu">=</span>
  liftM (<span class="fu">$</span>a) f</code></pre>
<p>The <code>fFlip</code> is available to use to a strict superset of the data types that <code>mFlip</code> is available to, yet they are both equivalent in power. It is desirable to implement <code>fFlip</code>. However, when we combine a usage of <code>fFlip</code> with a monad operation, our type constraint becomes <code>(Monad f, Functor f) =&gt;</code>, which is undesirable boilerplate because <code>Monad</code> implies <code>Functor</code>!</p>
<h3 id="monad-applicative-and-functor">Monad, Applicative and Functor</h3>
<p>A <a href="http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal">proposal to amend this introduces the <code>Applicative</code> type-class</a>, which sits between <code>Monad</code> and <code>Functor</code>. In other words, <code>Monad</code> extends <code>Applicative</code> and <code>Applicative</code> extends <code>Functor</code>. This is again, because the primitives of each superclass can be derived:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- derive fmap from the Applicative primitives, (&lt;*&gt;) and pure</span>
fmap <span class="ot">::</span>
  <span class="dt">Applicative</span> f <span class="ot">=&gt;</span>
  (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> f a
  <span class="ot">-&gt;</span> f b
fmap <span class="fu">=</span>
  (<span class="fu">&lt;*&gt;</span>) <span class="fu">.</span> pure

<span class="co">-- derive (&lt;*&gt;) and pure from the Monad primitives, (&gt;&gt;=) and return</span>
(<span class="fu">&lt;*&gt;</span>) <span class="ot">::</span>
  <span class="dt">Monad</span> f <span class="ot">=&gt;</span>
  f (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> f a
  <span class="ot">-&gt;</span> f b
f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span>
  <span class="kw">do</span> f&#39; <span class="ot">&lt;-</span> f
     a&#39; <span class="ot">&lt;-</span> a
     return (f&#39; a&#39;)

pure <span class="ot">::</span>
  <span class="dt">Monad</span> f <span class="ot">=&gt;</span>
  a
  <span class="ot">-&gt;</span> f a
pure <span class="fu">=</span>
  return</code></pre>
<h3 id="applicative-do-notation">Applicative do-notation</h3>
<p>With this proposal, there is <a href="http://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo">another proposal to extend do-notation</a> to take advantage of this improved flexibility. Currently, do-notation translates to the code that uses the <code>Monad</code> primitives, <code>(&gt;&gt;=)</code> and <code>return</code><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>There are some arguments against this proposal, because this extension is not always desirable. In particular, the degree to which values are shared may be affected. Consider:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">result <span class="fu">=</span>
  <span class="kw">do</span> a <span class="ot">&lt;-</span> expr
     b <span class="ot">&lt;-</span> spaceyExpr
     return (f a b)

<span class="co">-- monad desugaring (current)</span>
result <span class="fu">=</span>
  expr <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span>
  spaceyExpr <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>
  return (f a b)

<span class="co">-- applicative desugaring (proposed)</span>
result <span class="fu">=</span>
  fmap f expr <span class="fu">&lt;*&gt;</span> spaceyExpr</code></pre>
<p>Since <code>spaceyExpr</code>appears inside a lambda for the current desugaring, it will not be retained and so computed on each invocation of <code>a</code>. However, in the proposed desugaring, the value is retained and shared when the expression is evaluated. This could, of course, lead to surprises in space usage.</p>
<p>It might be argued that do-notation should maintain its current desugaring using <code>Monad</code> and introduce another means by which to perform <code>Applicative</code> desugaring.</p>
<p>Whatever the outcome, all of this distracts from the otherwise glaring oversight.</p>
<h3 id="no">No</h3>
<p>The Functor, Monad, Applicative proposal opens with the following paragraph:</p>
<pre><code>Haskell calls a couple of historical accidents its own. While some of them,
such as the &quot;number classes&quot; hierarchy, can be justified by pragmatism or
lack of a strictly better suggestion, there is one thing that stands out as,
well, not that: Applicative not being a superclass of Monad.</code></pre>
<p>It is my opinion that this proposal is about to commit <em>exactly the same historical mistake</em> that is attempting to be eschewed. Furthermore, by properly eliminating this mistake, the syntax proposal would be improved as a consequence.</p>
<p>Being a strong proponent of progress, and that Haskell is often pushing the front of progress, this makes me a bit sad :(</p>
<p>Fact: not all semigroups are monoids.</p>
<p>No desugaring, current or proposed, utilises the identity value. In the <code>Monad</code> case, this is <code>return</code> and in the <code>Applicative</code> case, this is <code>pure</code>. However, it is a requirement of users to implement these functions. There exist structures that can utilise the full power of this desugaring, but cannot provide the identity value. Therefore, we can eliminate the identity value and still exploit the full advantage of desugaring. Not only this, but it then makes operations available to a strict superset of data types.</p>
<p>Consider the following amendment to the proposal:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Apply</span> f <span class="kw">where</span>
  (<span class="fu">&lt;*&gt;</span>) <span class="ot">::</span>
    f (a <span class="ot">-&gt;</span> b)
    <span class="ot">-&gt;</span> f a
    <span class="ot">-&gt;</span> f b

<span class="kw">class</span> <span class="dt">Apply</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
  pure <span class="ot">::</span>
    a
    <span class="ot">-&gt;</span> f a</code></pre>
<p>We may still derive many of the ubiquitous functions, without the full power of <code>Applicative</code>.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">liftA2 <span class="ot">::</span>
  <span class="dt">Apply</span> f <span class="ot">=&gt;</span>
  (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)
  <span class="ot">-&gt;</span> f a
  <span class="ot">-&gt;</span> f b
  <span class="ot">-&gt;</span> f c
liftA2 f a b <span class="fu">=</span>
  fmap f a <span class="fu">&lt;*&gt;</span> b</code></pre>
<p>We may still exploit our do-notation:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">result <span class="fu">=</span>
  <span class="kw">do</span> a <span class="ot">&lt;-</span> expr1
     b <span class="ot">&lt;-</span> expr2
     return (f a b)

<span class="co">-- apply desugaring</span>
result <span class="fu">=</span>
  fmap f expr1 <span class="fu">&lt;*&gt;</span> expr2</code></pre>
<p>However, more to the point, there are now data structures for which these operations (e.g. <code>liftA2</code>) and do-notation become available, that otherwise would not have been.</p>
<p>Here are some examples of those:</p>
<h5 id="also">Also</h5>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NonEmptyList</span> a <span class="fu">=</span> <span class="dt">NEL</span> a [a]
<span class="kw">data</span> <span class="dt">Also</span> a x <span class="fu">=</span> <span class="dt">Also</span> (<span class="dt">NonEmptyList</span> a) x
<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Also</span> a) <span class="kw">where</span>
<span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">Also</span> a) <span class="kw">where</span>
  <span class="dt">Also</span> (<span class="dt">NEL</span> h t) f <span class="fu">&lt;*&gt;</span> <span class="dt">Also</span> (<span class="dt">NEL</span> h&#39; t&#39;) x <span class="fu">=</span>
    <span class="dt">Also</span> (<span class="dt">NEL</span> h (t <span class="fu">++</span> h&#39; <span class="fu">:</span> t&#39;)) (f x)</code></pre>
<p>The <code>Also</code> data type has no possible <code>Applicative</code> instance, yet it has a very usable <code>Apply</code>. This means we can use (amended) <code>liftA2</code> and do-notation on <code>Also</code> values, without losing any power.</p>
<p>This data type generalises in fact, while still maintaining an <code>Apply</code> instance.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Also</span> s x <span class="fu">=</span> <span class="dt">Also</span> s x</code></pre>
<p>There is an <code>Apply</code> instance for <code>(Also s)</code> for as long as there is a <code>Semigroup</code> instance for <code>s</code>, however, if your semigroup is not a monoid, then there is no <code>Monoid</code> instance. I have used <code>(NonEmptyList a)</code> as an example of a data type with a semigroup, but not a monoid.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span>
<span class="ot">  (&lt;&gt;) ::</span> <span class="co">-- associative</span>
    a
    <span class="ot">-&gt;</span> a
    <span class="ot">-&gt;</span> a

<span class="kw">instance</span> <span class="dt">Semigroup</span> s <span class="ot">=&gt;</span> <span class="dt">Apply</span> (<span class="dt">Also</span> s) <span class="kw">where</span>
  <span class="dt">Also</span> s1 f <span class="fu">&lt;*&gt;</span> <span class="dt">Also</span> s2 x <span class="fu">=</span>
    <span class="dt">Also</span> (s1 <span class="fu">&lt;&gt;</span> s2) (f x)</code></pre>
<h5 id="ornot">OrNot</h5>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OrNot</span> a <span class="fu">=</span> <span class="co">-- Maybe (NonEmptyList a)</span>
  <span class="dt">Not</span>
  <span class="fu">|</span> <span class="dt">Or</span> (<span class="dt">NonEmptyList</span> a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">OrNot</span> <span class="kw">where</span>

<span class="kw">instance</span> <span class="dt">Apply</span> <span class="dt">OrNot</span> <span class="kw">where</span>
  <span class="dt">Not</span> <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span>
    <span class="dt">Not</span>
  <span class="dt">Or</span> _ <span class="fu">&lt;*&gt;</span> <span class="dt">Not</span> <span class="fu">=</span>
    <span class="dt">Not</span>
  <span class="dt">Or</span> (<span class="dt">NEL</span> h t) <span class="fu">&lt;*&gt;</span> <span class="dt">Or</span> (<span class="dt">NEL</span> h&#39; t&#39;) <span class="fu">=</span>
    <span class="dt">Or</span> (<span class="dt">NEL</span> (h h&#39;) (t <span class="fu">&lt;*&gt;</span> t&#39;))</code></pre>
<p>The <code>OrNot</code> data is isomorphic to <code>Maybe (NonEmptyList a)</code> and has an <code>Apply</code> instance that is similar to the <code>Applicative</code> for <code>Maybe</code>. However, since this data type holds a non-empty list, there is no possibility for an <code>Applicative</code> instance.</p>
<p>Again, with an amended do-notation and library functions, we could use <code>OrNot</code> values.</p>
<h5 id="but-it-doesnt-stop-there">But it doesn’t stop there…</h5>
<p>Your regular old <code>Data.Map#Map</code> can provide an <code>Apply</code> instance, but not an <code>Applicative</code>.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Apply</span> (<span class="dt">Map</span> k) <span class="kw">where</span>
  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span>
    Map.intersectionWith (<span class="fu">$</span>)</code></pre>
<p>There is no corresponding <code>Applicative</code> instance for this <code>Apply</code> instance. This is the same story for <code>Data.IntMap#IntMap</code>.</p>
<p>I want to use <code>liftA2</code> and many other generalised functions on <code>(Map k)</code> values and no, I am not sorry!</p>
<h3 id="apply-not-applicative">Apply not Applicative</h3>
<p>I could go on and on with useful data types that have <code>Apply</code> instances, but no corresponding <code>Applicative</code>. However, I hope this is enough to illustrate the point.</p>
<p>If we are going to amend the type-class hierarchy, taking on all the compatibility issues of doing so, then let us provide a kick-arse solution. It is especially compelling in that this amendment to the proposal subsumes the existing error. Let us move on from yet another historical mistake that <a href="http://hackage.haskell.org/package/semigroupoids">has already been acknowledged</a>.</p>
<h3 id="bind-not-monad">Bind not Monad</h3>
<p>This story is not just about <code>Apply</code> and <code>Applicative</code>. All of the same reasoning applies to semi-monads or the <code>Bind</code> type-class. The <code>return</code> operation is not essential to do-notation or even many monad functions, so it is an unnecessary, imposed requirement for implementers of the <code>Monad</code> type-class.</p>
<p>Similarly, there are structures for which there is a <code>Bind</code> instance, but not a <code>Monad</code> instance.</p>
<h3 id="type-class-hierarchy-proper">Type-class Hierarchy Proper</h3>
<p>In order to take full advantage of a type-class amendment, I submit the following proposed type-class hierarchy. I contend that it subsumes the existing proposal by providing additional flexibility for zero additional loss.</p>
<p>Library functions, such as <code>liftA2</code>, could slowly adopt an amendment to their type signature so as to open up to more data types.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
  fmap <span class="ot">::</span>
    (a <span class="ot">-&gt;</span> b)
    <span class="ot">-&gt;</span> f a
    <span class="ot">-&gt;</span> f b

<span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Apply</span> f <span class="kw">where</span>
  (<span class="fu">&lt;*&gt;</span>) <span class="ot">::</span>
    f (a <span class="ot">-&gt;</span> b)
    <span class="ot">-&gt;</span> f a
    <span class="ot">-&gt;</span> f b

<span class="kw">class</span> <span class="dt">Apply</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
  pure <span class="ot">::</span>
    a
    <span class="ot">-&gt;</span> f a

<span class="kw">class</span> <span class="dt">Apply</span> f <span class="ot">=&gt;</span> <span class="dt">Bind</span> f <span class="kw">where</span>
  (<span class="fu">&gt;&gt;=</span>) <span class="ot">::</span>
    (a <span class="ot">-&gt;</span> f b)
    <span class="ot">-&gt;</span> f a
    <span class="ot">-&gt;</span> f b

<span class="kw">class</span> (<span class="dt">Applicative</span> f, <span class="dt">Bind</span> f) <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></code></pre>
<p>and while we’re at it…</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span>
<span class="ot">  (&lt;&gt;) ::</span> <span class="co">-- mappend</span>
    a
    <span class="ot">-&gt;</span> a
    <span class="ot">-&gt;</span> a

<span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
  mempty <span class="ot">::</span>
    a</code></pre>
<p>but maybe I am biting off a bit too much there :)</p>
<h3 id="addendum-on-pointed">Addendum on Pointed</h3>
<p>I have not mentioned the <code>Pointed</code> experiment, because it is not worth mentioning anymore. It was an experiment, executed in both Scala and Haskell, and the result is conclusive.</p>
<p>However, here is the type-class:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Pointed</span> f <span class="kw">where</span>
  pure <span class="ot">::</span>
    a
    <span class="ot">-&gt;</span> f a</code></pre>
<p>It was once proposed to slot in between <code>Applicative</code> and <code>Functor</code>. The <code>Pointed</code> type-class is not at all useful and there is no value in continuing discussion in this context, but instead about the result of the failed experiment. This is for another day.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There are other functions on <code>Monad</code>, but these are either derivable (e.g. <code>(&gt;&gt;)</code>) or a mistake and hindrance to discussion (e.g. <code>fail</code>).<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Monad Transformers at BFPG</title>
    <link href="http://blog.tmorris.net/posts/monad-transformers/index.html" />
    <id>http://blog.tmorris.net/posts/monad-transformers/index.html</id>
    <published>2013-09-03T12:00:00Z</published>
    <updated>2013-09-03T12:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A talk on monad transformers , delivered to <a href="http://www.meetup.com/Brisbane-Functional-Programming-Group/events/104664162/">Brisbane Functional Programming Group on Tuesday 27 August 2013</a>.</p>
<ul>
<li><p><a href="http://dl.dropbox.com/u/7810909/media/doc/monad-transformers.pdf">Slides</a> <em>(pdf)</em></p></li>
<li><p><a href="https://vimeo.com/73648150">Video</a> <em>(vimeo)</em></p></li>
</ul>
<div class="embed-vimeo">
<p><iframe src="http://player.vimeo.com/video/73648150" width="688" height="387" frameborder="0" webkitAllowFullScreen="true" mozallowfullscreen="true" allowFullScreen="true"> </iframe></p>
</div>]]></summary>
</entry>
<entry>
    <title>Refactoring Puzzle</title>
    <link href="http://blog.tmorris.net/posts/refactoring-puzzle/index.html" />
    <id>http://blog.tmorris.net/posts/refactoring-puzzle/index.html</id>
    <published>2013-06-05T20:00:00Z</published>
    <updated>2013-06-05T20:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The following programming puzzle is about code duplication. The goal is to identify and remove the code duplication. The exercise is given in a number of programming languages and the means by which the problem is solved may depend on the specific programming language. It might even be the case that the best solution is “do nothing”, since the programming language does not provide the support for alleviating the code duplication. Therefore, a complete solution to this puzzle is a solution for each of the programming languages.</p>
<p>The two functions <code>runOptions</code> and <code>runIntRdrs</code> implement a specific function with a small difference between each. The duplication in their code bodies is noted in the comments and is denoted by asterisks.</p>
<p><strong>How might the problem of code duplication be solved for this case?</strong></p>
<p>The puzzle is designed to compile as-is, which means for some languages, support data structures need to be provided. For example, the C# programming language does not provide an immutable (cons) list data structure, so the bare minimum is supplied here. This makes the puzzle appear quite noisy for that specific programming language, however be assured it is the same code.</p>
<h1 id="scala">Scala</h1>
<pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">object</span> RefactorPuzzle {
  <span class="kw">case</span> <span class="kw">class</span> IntRdr[+A](read: Int =&gt; A) {
    <span class="kw">def</span> map[B](f: A =&gt; B): IntRdr[B] =
      <span class="fu">IntRdr</span>(f compose read)

    <span class="kw">def</span> flatMap[B](f: A =&gt; IntRdr[B]): IntRdr[B] =
      <span class="fu">IntRdr</span>(n =&gt; <span class="fu">f</span>(<span class="fu">read</span>(n)).<span class="fu">read</span>(n))
  }

  <span class="kw">object</span> IntRdr {
    <span class="kw">def</span> apply[A](a: A): IntRdr[A] =
      <span class="fu">IntRdr</span>(_ =&gt; a)
  }

  <span class="co">// Return all the Some values, or None if not all are Some.</span>
  <span class="kw">def</span> runOptions[A](x: List[Option[A]]): Option[List[A]] =
    x.<span class="fu">foldRight</span>[Option[List[A]]](Option(Nil))((a, b) =&gt; a.<span class="fu">flatMap</span>(aa =&gt; b.<span class="fu">map</span>(aa :: _)))

  <span class="co">// Apply an Int to a list of int readers and return the list of return values.</span>
  <span class="kw">def</span> runIntRdrs[A](x: List[IntRdr[A]]): IntRdr[List[A]] =
    x.<span class="fu">foldRight</span>[IntRdr[List[A]]](<span class="fu">IntRdr</span>(Nil))((a, b) =&gt; a.<span class="fu">flatMap</span>(aa =&gt; b.<span class="fu">map</span>(aa :: _)))

<span class="co">// Code Duplication</span>

<span class="co">// *******      *************      *******      ***********</span>
<span class="co">// def runOptions[A](x: List[Option[A]]): Option[List[A]] =</span>
<span class="co">// def runIntRdrs[A](x: List[IntRdr[A]]): IntRdr[List[A]] =</span>

<span class="co">// ************      ***********      *************************************************</span>
<span class="co">// x.foldRight[Option[List[A]]](Option(Nil))((a, b) =&gt; a.flatMap(aa =&gt; b.map(aa :: _)))</span>
<span class="co">// x.foldRight[IntRdr[List[A]]](IntRdr(Nil))((a, b) =&gt; a.flatMap(aa =&gt; b.map(aa :: _)))</span>

}</code></pre>
<h1 id="haskell">Haskell</h1>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">RefactoringPuzzle</span> <span class="kw">where</span>

<span class="kw">newtype</span> <span class="dt">IntRdr</span> a <span class="fu">=</span>
  <span class="dt">IntRdr</span> {
<span class="ot">    readIntRdr ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
  }

mapIntRdr <span class="ot">::</span>
  <span class="dt">IntRdr</span> a
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> b
mapIntRdr (<span class="dt">IntRdr</span> g) f <span class="fu">=</span>
  <span class="dt">IntRdr</span> (f <span class="fu">.</span> g)

bindIntRdr <span class="ot">::</span>
  <span class="dt">IntRdr</span> a
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> b)
  <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> b
bindIntRdr (<span class="dt">IntRdr</span> g) f <span class="fu">=</span>
  <span class="dt">IntRdr</span> (\n <span class="ot">-&gt;</span> readIntRdr (f (g n)) n)

applyIntRdr <span class="ot">::</span>
  a
  <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> a
applyIntRdr <span class="fu">=</span>
  <span class="dt">IntRdr</span> <span class="fu">.</span> const

<span class="kw">type</span> <span class="dt">Option</span> <span class="fu">=</span> <span class="dt">Maybe</span>

mapOption <span class="ot">::</span>
  <span class="dt">Option</span> a
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> <span class="dt">Option</span> b
mapOption <span class="dt">Nothing</span> _ <span class="fu">=</span>
  <span class="dt">Nothing</span>
mapOption (<span class="dt">Just</span> a) f <span class="fu">=</span>
  <span class="dt">Just</span> (f a)

bindOption <span class="ot">::</span>
  <span class="dt">Option</span> a
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Option</span> b)
  <span class="ot">-&gt;</span> <span class="dt">Option</span> b
bindOption <span class="dt">Nothing</span> _ <span class="fu">=</span>
  <span class="dt">Nothing</span>
bindOption (<span class="dt">Just</span> a) f <span class="fu">=</span>
  f a

applyOption <span class="ot">::</span>
  a
  <span class="ot">-&gt;</span> <span class="dt">Option</span> a
applyOption a <span class="fu">=</span>
  <span class="dt">Just</span> a

<span class="co">-- Return all the Some values, or None if not all are Some.</span>
<span class="ot">runOptions ::</span> [<span class="dt">Option</span> a] <span class="ot">-&gt;</span> <span class="dt">Option</span> [a]
runOptions <span class="fu">=</span> foldr (\a b <span class="ot">-&gt;</span> bindOption a (\aa <span class="ot">-&gt;</span> mapOption b (aa<span class="fu">:</span>))) (applyOption [])

<span class="co">-- Apply an Int to a list of int readers and return the list of return values.</span>
<span class="ot">runIntRdrs ::</span> [<span class="dt">IntRdr</span> a] <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> [a]
runIntRdrs <span class="fu">=</span> foldr (\a b <span class="ot">-&gt;</span> bindIntRdr a (\aa <span class="ot">-&gt;</span> mapIntRdr b (aa<span class="fu">:</span>))) (applyIntRdr [])

<span class="co">-- Code Duplication</span>

<span class="co">-- ***      ******      *******      ****</span>
<span class="co">-- runOptions :: [Option a] -&gt; Option [a]</span>
<span class="co">-- runIntRdrs :: [IntRdr a] -&gt; IntRdr [a]</span>

<span class="co">-- ***      ***********************      **************      ************           ****</span>
<span class="co">-- runOptions = foldr (\a b -&gt; bindOption a (\aa -&gt; mapOption b (aa:))) (applyOption [])</span>
<span class="co">-- runIntRdrs = foldr (\a b -&gt; bindIntRdr a (\aa -&gt; mapIntRdr b (aa:))) (applyIntRdr [])</span></code></pre>
<h1 id="c">C#</h1>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">using</span> System;

<span class="kw">namespace</span> RefactoringPuzzle {
<span class="kw">class</span> IntRdr&lt;A&gt; {
  <span class="kw">public</span> <span class="kw">readonly</span> Func&lt;<span class="dt">int</span>, A&gt; read;

  <span class="fu">IntRdr</span>(Func&lt;<span class="dt">int</span>, A&gt; read) {
    <span class="kw">this</span>.<span class="fu">read</span> = read;
  }

  <span class="kw">public</span> IntRdr&lt;B&gt; Select&lt;B&gt;(Func&lt;A, B&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;B&gt;(n =&gt; <span class="fu">f</span>(<span class="fu">read</span>(n)));
  }

  <span class="kw">public</span> IntRdr&lt;B&gt; SelectMany&lt;B&gt;(Func&lt;A, IntRdr&lt;B&gt;&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;B&gt;(n =&gt; <span class="fu">f</span>(<span class="fu">read</span>(n)).<span class="fu">read</span>(n));
  }

  <span class="kw">public</span> <span class="kw">static</span> IntRdr&lt;A&gt; <span class="fu">apply</span>(A a) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;A&gt;(_ =&gt; a);
  }
}

<span class="kw">abstract</span> <span class="kw">class</span> Option&lt;A&gt; {
  <span class="kw">public</span> <span class="kw">abstract</span> X Fold&lt;X&gt;(Func&lt;A, X&gt; some, X none);

  <span class="kw">public</span> Option&lt;B&gt; Select&lt;B&gt;(Func&lt;A, B&gt; f) {
    <span class="kw">return</span> Fold&lt;Option&lt;B&gt;&gt;(a =&gt; <span class="kw">new</span> Option&lt;B&gt;.<span class="fu">Some</span>(<span class="fu">f</span>(a)), <span class="kw">new</span> Option&lt;B&gt;.<span class="fu">None</span>());
  }

  <span class="kw">public</span> Option&lt;B&gt; SelectMany&lt;B&gt;(Func&lt;A, Option&lt;B&gt;&gt; f) {
    <span class="kw">return</span> <span class="fu">Fold</span>(f, <span class="kw">new</span> Option&lt;B&gt;.<span class="fu">None</span>());
  }

  <span class="kw">public</span> <span class="kw">static</span> Option&lt;A&gt; <span class="fu">apply</span>(A a) {
    <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Some</span>(a);
  }

  <span class="kw">public</span> <span class="kw">class</span> Some : Option&lt;A&gt; {
    <span class="kw">readonly</span> A a;

    <span class="kw">public</span> <span class="fu">Some</span>(A a) {
      <span class="kw">this</span>.<span class="fu">a</span> = a;
    }

    <span class="kw">public</span> <span class="kw">override</span> X Fold&lt;X&gt;(Func&lt;A, X&gt; some, X none) {
      <span class="kw">return</span> <span class="fu">some</span>(a);
    }
  }

  <span class="kw">public</span> <span class="kw">class</span> None : Option&lt;A&gt; {
    <span class="kw">public</span> <span class="kw">override</span> X Fold&lt;X&gt;(Func&lt;A, X&gt; some, X none) {
      <span class="kw">return</span> none;
    }
  }
}

<span class="kw">abstract</span> <span class="kw">class</span> List&lt;A&gt; {
  <span class="kw">public</span> <span class="kw">abstract</span> X FoldRight&lt;X&gt;(Func&lt;A, X, X&gt; f, X x);

  <span class="co">// Return all the Some values, or None if not all are Some.</span>
  Option&lt;List&lt;A&gt;&gt; <span class="fu">runOptions</span>(List&lt;Option&lt;A&gt;&gt; x) {
    <span class="kw">return</span> x.<span class="fu">FoldRight</span>((a, b) =&gt; a.<span class="fu">SelectMany</span>(aa =&gt;
      b.<span class="fu">Select</span>(bb =&gt; bb.<span class="fu">Prepend</span>(aa))), Option&lt;List&lt;A&gt;&gt;.<span class="fu">apply</span>(<span class="kw">new</span> <span class="fu">Nil</span>()));
  }

  <span class="co">// Apply an Int to a list of int readers and return the list of return values.</span>
  IntRdr&lt;List&lt;A&gt;&gt; <span class="fu">runIntRdrs</span>(List&lt;IntRdr&lt;A&gt;&gt; x) {
    <span class="kw">return</span> x.<span class="fu">FoldRight</span>((a, b) =&gt; a.<span class="fu">SelectMany</span>(aa =&gt;
      b.<span class="fu">Select</span>(bb =&gt; bb.<span class="fu">Prepend</span>(aa))), IntRdr&lt;List&lt;A&gt;&gt;.<span class="fu">apply</span>(<span class="kw">new</span> <span class="fu">Nil</span>()));
  }

  <span class="kw">public</span> List&lt;A&gt; <span class="fu">Prepend</span>(A a) {
    <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Cons</span>(a, <span class="kw">this</span>);
  }

  <span class="kw">public</span> <span class="kw">class</span> Nil : List&lt;A&gt; {
    <span class="kw">public</span> <span class="kw">override</span> X FoldRight&lt;X&gt;(Func&lt;A, X, X&gt; f, X x) {
      <span class="kw">return</span> x;
    }
  }

  <span class="kw">public</span> <span class="kw">class</span> Cons : List&lt;A&gt; {
    <span class="kw">readonly</span> A head;
    <span class="kw">readonly</span> List&lt;A&gt; tail;

    <span class="kw">public</span> <span class="fu">Cons</span>(A head, List&lt;A&gt; tail) {
      <span class="kw">this</span>.<span class="fu">head</span> = head;
      <span class="kw">this</span>.<span class="fu">tail</span> = tail;
    }

    <span class="kw">public</span> <span class="kw">override</span> X FoldRight&lt;X&gt;(Func&lt;A, X, X&gt; f, X x) {
      <span class="kw">return</span> <span class="fu">f</span>(head, tail.<span class="fu">FoldRight</span>(f, x));
    }
  }
}

<span class="co">// Code Duplication</span>

<span class="co">//       *************      *******      *********</span>
<span class="co">// Option&lt;List&lt;A&gt;&gt; runOptions(List&lt;Option&lt;A&gt;&gt; x) {</span>
<span class="co">// IntRdr&lt;List&lt;A&gt;&gt; runIntRdrs(List&lt;IntRdr&lt;A&gt;&gt; x) {</span>

<span class="co">// ***********************************************</span>
<span class="co">// return x.FoldRight((a, b) =&gt; a.SelectMany(aa =&gt;</span>
<span class="co">// return x.FoldRight((a, b) =&gt; a.SelectMany(aa =&gt;</span>

<span class="co">// *********************************      ****************************</span>
<span class="co">// b.Select(bb =&gt; bb.Prepend(aa))), Option&lt;List&lt;A&gt;&gt;.apply(new Nil()));</span>
<span class="co">// b.Select(bb =&gt; bb.Prepend(aa))), IntRdr&lt;List&lt;A&gt;&gt;.apply(new Nil()));</span>

}</code></pre>
<h1 id="java">Java</h1>
<pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">package RefactoringPuzzle;</span>

<span class="kw">abstract</span> <span class="kw">class</span> Func&lt;T, U&gt; {
  <span class="kw">abstract</span> U <span class="fu">apply</span>(T t);
}

<span class="kw">abstract</span> <span class="kw">class</span> IntRdr&lt;A&gt; {
  <span class="kw">abstract</span> A <span class="fu">read</span>(<span class="dt">int</span> i);

  &lt;B&gt; IntRdr&lt;B&gt; <span class="fu">map</span>(<span class="dt">final</span> Func&lt;A, B&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;B&gt;() {
      B <span class="fu">read</span>(<span class="dt">int</span> i) {
        <span class="kw">return</span> f.<span class="fu">apply</span>(IntRdr.<span class="fu">this</span>.<span class="fu">read</span>(i));
      }
    };
  }

  &lt;B&gt; IntRdr&lt;B&gt; <span class="fu">bind</span>(<span class="dt">final</span> Func&lt;A, IntRdr&lt;B&gt;&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;B&gt;() {
      B <span class="fu">read</span>(<span class="dt">int</span> i) {
        <span class="kw">return</span> f.<span class="fu">apply</span>(IntRdr.<span class="fu">this</span>.<span class="fu">read</span>(i)).<span class="fu">read</span>(i);
      }
    };
  }

  <span class="dt">static</span> &lt;A&gt; IntRdr&lt;A&gt; <span class="fu">apply</span>(<span class="dt">final</span> A a) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;A&gt;() {
      A <span class="fu">read</span>(<span class="dt">int</span> _) {
        <span class="kw">return</span> a;
      }
    };
  }
}

<span class="kw">abstract</span> <span class="kw">class</span> Option&lt;A&gt; {
  <span class="kw">abstract</span> &lt;X&gt; X <span class="fu">fold</span>(Func&lt;A, X&gt; some, X none);

  &lt;B&gt; Option&lt;B&gt; <span class="fu">map</span>(<span class="dt">final</span> Func&lt;A, B&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> Option&lt;B&gt;() {
      &lt;X&gt; X <span class="fu">fold</span>(<span class="dt">final</span> Func&lt;B, X&gt; some, X none) {
        <span class="kw">return</span> Option.<span class="fu">this</span>.<span class="fu">fold</span>(<span class="kw">new</span> Func&lt;A, X&gt;(){
          X <span class="fu">apply</span>(A a) {
            <span class="kw">return</span> some.<span class="fu">apply</span>(f.<span class="fu">apply</span>(a));
          }
        }, none);
      }
    };
  }

  &lt;B&gt; Option&lt;B&gt; <span class="fu">bind</span>(<span class="dt">final</span> Func&lt;A, Option&lt;B&gt;&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> Option&lt;B&gt;() {
      &lt;X&gt; X <span class="fu">fold</span>(<span class="dt">final</span> Func&lt;B, X&gt; some, <span class="dt">final</span> X none) {
        <span class="kw">return</span> Option.<span class="fu">this</span>.<span class="fu">fold</span>(<span class="kw">new</span> Func&lt;A, X&gt;(){
          X <span class="fu">apply</span>(A a) {
            <span class="kw">return</span> f.<span class="fu">apply</span>(a).<span class="fu">fold</span>(some, none);
          }
        }, none);
      }
    };
  }

  <span class="dt">static</span> &lt;A&gt; Option&lt;A&gt; <span class="fu">apply</span>(<span class="dt">final</span> A a) {
    <span class="kw">return</span> <span class="kw">new</span> Option&lt;A&gt;() {
      &lt;X&gt; X <span class="fu">fold</span>(Func&lt;A, X&gt; some, X none) {
        <span class="kw">return</span> some.<span class="fu">apply</span>(a);
      }
    };
  }
}

<span class="kw">abstract</span> <span class="kw">class</span> List&lt;A&gt; {
  <span class="kw">abstract</span> &lt;X&gt; X <span class="fu">foldRight</span>(Func&lt;A, Func&lt;X, X&gt;&gt; f, X x);

  <span class="co">// Return all the Some values, or None if not all are Some.</span>
  <span class="dt">static</span> &lt;A&gt; Option&lt;List&lt;A&gt;&gt; <span class="fu">runOptions</span>(List&lt;Option&lt;A&gt;&gt; x) {
    <span class="kw">return</span> x.<span class="fu">foldRight</span>(<span class="kw">new</span> Func&lt;Option&lt;A&gt;, Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt;&gt;(){
      Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> Option&lt;A&gt; a) {
        <span class="kw">return</span> <span class="kw">new</span> Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt;() {
          Option&lt;List&lt;A&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> Option&lt;List&lt;A&gt;&gt; b) {
            <span class="kw">return</span> a.<span class="fu">bind</span>(<span class="kw">new</span> Func&lt;A, Option&lt;List&lt;A&gt;&gt;&gt;(){
              Option&lt;List&lt;A&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> A aa) {
                <span class="kw">return</span> b.<span class="fu">map</span>(<span class="kw">new</span> Func&lt;List&lt;A&gt;, List&lt;A&gt;&gt;(){
                  List&lt;A&gt; <span class="fu">apply</span>(List&lt;A&gt; bb) {
                    <span class="kw">return</span> bb.<span class="fu">prepend</span>(aa);
                  }
                });
              }
            });
          }
        };
      }
    }, Option.<span class="fu">apply</span>(List.&lt;A&gt;<span class="fu">nil</span>()));
  }

  <span class="co">// Apply an Int to a list of int readers and return the list of return values.</span>
  <span class="dt">static</span> &lt;A&gt; IntRdr&lt;List&lt;A&gt;&gt; <span class="fu">runIntRdrs</span>(List&lt;IntRdr&lt;A&gt;&gt; x) {
    <span class="kw">return</span> x.<span class="fu">foldRight</span>(<span class="kw">new</span> Func&lt;IntRdr&lt;A&gt;, Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt;&gt;(){
      Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> IntRdr&lt;A&gt; a) {
        <span class="kw">return</span> <span class="kw">new</span> Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt;() {
          IntRdr&lt;List&lt;A&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> IntRdr&lt;List&lt;A&gt;&gt; b) {
            <span class="kw">return</span> a.<span class="fu">bind</span>(<span class="kw">new</span> Func&lt;A, IntRdr&lt;List&lt;A&gt;&gt;&gt;(){
              IntRdr&lt;List&lt;A&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> A aa) {
                <span class="kw">return</span> b.<span class="fu">map</span>(<span class="kw">new</span> Func&lt;List&lt;A&gt;, List&lt;A&gt;&gt;(){
                  List&lt;A&gt; <span class="fu">apply</span>(List&lt;A&gt; bb) {
                    <span class="kw">return</span> bb.<span class="fu">prepend</span>(aa);
                  }
                });
              }
            });
          }
        };
      }
    }, IntRdr.<span class="fu">apply</span>(List.&lt;A&gt;<span class="fu">nil</span>()));
  }

  List&lt;A&gt; <span class="fu">prepend</span>(<span class="dt">final</span> A a) {
    <span class="kw">return</span> <span class="kw">new</span> List&lt;A&gt;() {
      &lt;X&gt; X <span class="fu">foldRight</span>(Func&lt;A, Func&lt;X, X&gt;&gt; f, X x) {
        <span class="kw">return</span> f.<span class="fu">apply</span>(a).<span class="fu">apply</span>(<span class="kw">this</span>.<span class="fu">foldRight</span>(f, x));
      }
    };
  }

  <span class="dt">static</span> &lt;A&gt; List&lt;A&gt; <span class="fu">nil</span>() {
    <span class="kw">return</span> <span class="kw">new</span> List&lt;A&gt;() {
      &lt;X&gt; X <span class="fu">foldRight</span>(Func&lt;A, Func&lt;X, X&gt;&gt; f, X x) {
        <span class="kw">return</span> x;
      }
    };
  }
}

<span class="co">// Code Duplication</span>

<span class="co">// ***********      *************      *******      *********</span>
<span class="co">// static &lt;A&gt; Option&lt;List&lt;A&gt;&gt; runOptions(List&lt;Option&lt;A&gt;&gt; x) {</span>
<span class="co">// static &lt;A&gt; IntRdr&lt;List&lt;A&gt;&gt; runIntRdrs(List&lt;IntRdr&lt;A&gt;&gt; x) {</span>

<span class="co">//   ****************************      **********      ***********      **************</span>
<span class="co">//   return x.foldRight(new Func&lt;Option&lt;A&gt;, Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt;&gt;(){</span>
<span class="co">//   return x.foldRight(new Func&lt;IntRdr&lt;A&gt;, Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt;&gt;(){</span>

<span class="co">//     *****      ***********      ***********************      ********</span>
<span class="co">//     Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt; apply(final Option&lt;A&gt; a) {</span>
<span class="co">//     Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt; apply(final IntRdr&lt;A&gt; a) {</span>

<span class="co">//       ****************      ***********      **************</span>
<span class="co">//       return new Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt;() {</span>
<span class="co">//       return new Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt;() {</span>

<span class="co">//               **********************      **************</span>
<span class="co">//         Option&lt;List&lt;A&gt;&gt; apply(final Option&lt;List&lt;A&gt;&gt; b) {</span>
<span class="co">//         IntRdr&lt;List&lt;A&gt;&gt; apply(final IntRdr&lt;List&lt;A&gt;&gt; b) {</span>

<span class="co">//           **************************      *************</span>
<span class="co">//           return a.bind(new Func&lt;A, Option&lt;List&lt;A&gt;&gt;&gt;(){</span>
<span class="co">//           return a.bind(new Func&lt;A, IntRdr&lt;List&lt;A&gt;&gt;&gt;(){</span>

<span class="co">//                   *****************************</span>
<span class="co">//             Option&lt;List&lt;A&gt;&gt; apply(final A aa) {</span>
<span class="co">//             IntRdr&lt;List&lt;A&gt;&gt; apply(final A aa) {</span>

<span class="co">//               ******************************************</span>
<span class="co">//               return b.map(new Func&lt;List&lt;A&gt;, List&lt;A&gt;&gt;(){</span>
<span class="co">//               return b.map(new Func&lt;List&lt;A&gt;, List&lt;A&gt;&gt;(){</span>

<span class="co">//                 ***************************</span>
<span class="co">//                 List&lt;A&gt; apply(List&lt;A&gt; bb) {</span>
<span class="co">//                 List&lt;A&gt; apply(List&lt;A&gt; bb) {</span>

<span class="co">//                   **********************</span>
<span class="co">//                   return bb.prepend(aa);</span>
<span class="co">//                   return bb.prepend(aa);</span>
  …
<span class="co">//   ***      ***********************</span>
<span class="co">//   }, Option.apply(List.&lt;A&gt;nil()));</span>
<span class="co">//   }, IntRdr.apply(List.&lt;A&gt;nil()));</span>
  …</code></pre>]]></summary>
</entry>
<entry>
    <title>List Folds at BFPG</title>
    <link href="http://blog.tmorris.net/posts/list-folds-bfpg/index.html" />
    <id>http://blog.tmorris.net/posts/list-folds-bfpg/index.html</id>
    <published>2013-04-24T15:00:00Z</published>
    <updated>2013-04-24T15:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A talk on the list fold functions (fold left and fold right), delivered to <a href="http://www.bfpg.org/events/96368322/?eventId=96368322&amp;action=detail">Brisbane Functional Programming Group on Tuesday 23 April 2013</a>.</p>
<ul>
<li><p><a href="http://dl.dropbox.com/u/7810909/media/doc/list-folds.pdf">Slides</a> <em>(pdf)</em></p></li>
<li><p><a href="https://vimeo.com/64673035">Video</a> <em>(vimeo)</em></p></li>
</ul>
<div class="embed-vimeo">
<p><iframe src="http://player.vimeo.com/video/64673035" width="688" height="387" frameborder="0" webkitAllowFullScreen="true" mozallowfullscreen="true" allowFullScreen="true"> </iframe></p>
</div>]]></summary>
</entry>

</feed>
