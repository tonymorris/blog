<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>λ Tony's blog λ — Posts tagged C#</title>
    <link href="http://blog.tmorris.net/tags/C%23.xml" rel="self" />
    <link href="http://blog.tmorris.net" />
    <id>http://blog.tmorris.net/tags/C%23.xml</id>
    <author>
        <name>Tony Morris</name>
        <email>blog@tmorris.net</email>
    </author>
    <updated>2013-06-05T20:00:00Z</updated>
    <entry>
    <title>Refactoring Puzzle</title>
    <link href="http://blog.tmorris.net/posts/refactoring-puzzle/index.html" />
    <id>http://blog.tmorris.net/posts/refactoring-puzzle/index.html</id>
    <published>2013-06-05T20:00:00Z</published>
    <updated>2013-06-05T20:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The following programming puzzle is about code duplication. The goal is to identify and remove the code duplication. The exercise is given in a number of programming languages and the means by which the problem is solved may depend on the specific programming language. It might even be the case that the best solution is “do nothing”, since the programming language does not provide the support for alleviating the code duplication. Therefore, a complete solution to this puzzle is a solution for each of the programming languages.</p>
<p>The two functions <code>runOptions</code> and <code>runIntRdrs</code> implement a specific function with a small difference between each. The duplication in their code bodies is noted in the comments and is denoted by asterisks.</p>
<p><strong>How might the problem of code duplication be solved for this case?</strong></p>
<p>The puzzle is designed to compile as-is, which means for some languages, support data structures need to be provided. For example, the C# programming language does not provide an immutable (cons) list data structure, so the bare minimum is supplied here. This makes the puzzle appear quite noisy for that specific programming language, however be assured it is the same code.</p>
<h1 id="scala">Scala</h1>
<pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">object</span> RefactorPuzzle {
  <span class="kw">case</span> <span class="kw">class</span> IntRdr[+A](read: Int =&gt; A) {
    <span class="kw">def</span> map[B](f: A =&gt; B): IntRdr[B] =
      <span class="fu">IntRdr</span>(f compose read)

    <span class="kw">def</span> flatMap[B](f: A =&gt; IntRdr[B]): IntRdr[B] =
      <span class="fu">IntRdr</span>(n =&gt; <span class="fu">f</span>(<span class="fu">read</span>(n)).<span class="fu">read</span>(n))
  }

  <span class="kw">object</span> IntRdr {
    <span class="kw">def</span> apply[A](a: A): IntRdr[A] =
      <span class="fu">IntRdr</span>(_ =&gt; a)
  }

  <span class="co">// Return all the Some values, or None if not all are Some.</span>
  <span class="kw">def</span> runOptions[A](x: List[Option[A]]): Option[List[A]] =
    x.<span class="fu">foldRight</span>[Option[List[A]]](Option(Nil))((a, b) =&gt; a.<span class="fu">flatMap</span>(aa =&gt; b.<span class="fu">map</span>(aa :: _)))

  <span class="co">// Apply an Int to a list of int readers and return the list of return values.</span>
  <span class="kw">def</span> runIntRdrs[A](x: List[IntRdr[A]]): IntRdr[List[A]] =
    x.<span class="fu">foldRight</span>[IntRdr[List[A]]](<span class="fu">IntRdr</span>(Nil))((a, b) =&gt; a.<span class="fu">flatMap</span>(aa =&gt; b.<span class="fu">map</span>(aa :: _)))

<span class="co">// Code Duplication</span>

<span class="co">// *******      *************      *******      ***********</span>
<span class="co">// def runOptions[A](x: List[Option[A]]): Option[List[A]] =</span>
<span class="co">// def runIntRdrs[A](x: List[IntRdr[A]]): IntRdr[List[A]] =</span>

<span class="co">// ************      ***********      *************************************************</span>
<span class="co">// x.foldRight[Option[List[A]]](Option(Nil))((a, b) =&gt; a.flatMap(aa =&gt; b.map(aa :: _)))</span>
<span class="co">// x.foldRight[IntRdr[List[A]]](IntRdr(Nil))((a, b) =&gt; a.flatMap(aa =&gt; b.map(aa :: _)))</span>

}</code></pre>
<h1 id="haskell">Haskell</h1>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">RefactoringPuzzle</span> <span class="kw">where</span>

<span class="kw">newtype</span> <span class="dt">IntRdr</span> a <span class="fu">=</span>
  <span class="dt">IntRdr</span> {
<span class="ot">    readIntRdr ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
  }

mapIntRdr <span class="ot">::</span>
  <span class="dt">IntRdr</span> a
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> b
mapIntRdr (<span class="dt">IntRdr</span> g) f <span class="fu">=</span>
  <span class="dt">IntRdr</span> (f <span class="fu">.</span> g)

bindIntRdr <span class="ot">::</span>
  <span class="dt">IntRdr</span> a
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> b)
  <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> b
bindIntRdr (<span class="dt">IntRdr</span> g) f <span class="fu">=</span>
  <span class="dt">IntRdr</span> (\n <span class="ot">-&gt;</span> readIntRdr (f (g n)) n)

applyIntRdr <span class="ot">::</span>
  a
  <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> a
applyIntRdr <span class="fu">=</span>
  <span class="dt">IntRdr</span> <span class="fu">.</span> const

<span class="kw">type</span> <span class="dt">Option</span> <span class="fu">=</span> <span class="dt">Maybe</span>

mapOption <span class="ot">::</span>
  <span class="dt">Option</span> a
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)
  <span class="ot">-&gt;</span> <span class="dt">Option</span> b
mapOption <span class="dt">Nothing</span> _ <span class="fu">=</span>
  <span class="dt">Nothing</span>
mapOption (<span class="dt">Just</span> a) f <span class="fu">=</span>
  <span class="dt">Just</span> (f a)

bindOption <span class="ot">::</span>
  <span class="dt">Option</span> a
  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Option</span> b)
  <span class="ot">-&gt;</span> <span class="dt">Option</span> b
bindOption <span class="dt">Nothing</span> _ <span class="fu">=</span>
  <span class="dt">Nothing</span>
bindOption (<span class="dt">Just</span> a) f <span class="fu">=</span>
  f a

applyOption <span class="ot">::</span>
  a
  <span class="ot">-&gt;</span> <span class="dt">Option</span> a
applyOption a <span class="fu">=</span>
  <span class="dt">Just</span> a

<span class="co">-- Return all the Some values, or None if not all are Some.</span>
<span class="ot">runOptions ::</span> [<span class="dt">Option</span> a] <span class="ot">-&gt;</span> <span class="dt">Option</span> [a]
runOptions <span class="fu">=</span> foldr (\a b <span class="ot">-&gt;</span> bindOption a (\aa <span class="ot">-&gt;</span> mapOption b (aa<span class="fu">:</span>))) (applyOption [])

<span class="co">-- Apply an Int to a list of int readers and return the list of return values.</span>
<span class="ot">runIntRdrs ::</span> [<span class="dt">IntRdr</span> a] <span class="ot">-&gt;</span> <span class="dt">IntRdr</span> [a]
runIntRdrs <span class="fu">=</span> foldr (\a b <span class="ot">-&gt;</span> bindIntRdr a (\aa <span class="ot">-&gt;</span> mapIntRdr b (aa<span class="fu">:</span>))) (applyIntRdr [])

<span class="co">-- Code Duplication</span>

<span class="co">-- ***      ******      *******      ****</span>
<span class="co">-- runOptions :: [Option a] -&gt; Option [a]</span>
<span class="co">-- runIntRdrs :: [IntRdr a] -&gt; IntRdr [a]</span>

<span class="co">-- ***      ***********************      **************      ************           ****</span>
<span class="co">-- runOptions = foldr (\a b -&gt; bindOption a (\aa -&gt; mapOption b (aa:))) (applyOption [])</span>
<span class="co">-- runIntRdrs = foldr (\a b -&gt; bindIntRdr a (\aa -&gt; mapIntRdr b (aa:))) (applyIntRdr [])</span></code></pre>
<h1 id="c">C#</h1>
<pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">using</span> System;

<span class="kw">namespace</span> RefactoringPuzzle {
<span class="kw">class</span> IntRdr&lt;A&gt; {
  <span class="kw">public</span> <span class="kw">readonly</span> Func&lt;<span class="dt">int</span>, A&gt; read;

  <span class="fu">IntRdr</span>(Func&lt;<span class="dt">int</span>, A&gt; read) {
    <span class="kw">this</span>.<span class="fu">read</span> = read;
  }

  <span class="kw">public</span> IntRdr&lt;B&gt; Select&lt;B&gt;(Func&lt;A, B&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;B&gt;(n =&gt; <span class="fu">f</span>(<span class="fu">read</span>(n)));
  }

  <span class="kw">public</span> IntRdr&lt;B&gt; SelectMany&lt;B&gt;(Func&lt;A, IntRdr&lt;B&gt;&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;B&gt;(n =&gt; <span class="fu">f</span>(<span class="fu">read</span>(n)).<span class="fu">read</span>(n));
  }

  <span class="kw">public</span> <span class="kw">static</span> IntRdr&lt;A&gt; <span class="fu">apply</span>(A a) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;A&gt;(_ =&gt; a);
  }
}

<span class="kw">abstract</span> <span class="kw">class</span> Option&lt;A&gt; {
  <span class="kw">public</span> <span class="kw">abstract</span> X Fold&lt;X&gt;(Func&lt;A, X&gt; some, X none);

  <span class="kw">public</span> Option&lt;B&gt; Select&lt;B&gt;(Func&lt;A, B&gt; f) {
    <span class="kw">return</span> Fold&lt;Option&lt;B&gt;&gt;(a =&gt; <span class="kw">new</span> Option&lt;B&gt;.<span class="fu">Some</span>(<span class="fu">f</span>(a)), <span class="kw">new</span> Option&lt;B&gt;.<span class="fu">None</span>());
  }

  <span class="kw">public</span> Option&lt;B&gt; SelectMany&lt;B&gt;(Func&lt;A, Option&lt;B&gt;&gt; f) {
    <span class="kw">return</span> <span class="fu">Fold</span>(f, <span class="kw">new</span> Option&lt;B&gt;.<span class="fu">None</span>());
  }

  <span class="kw">public</span> <span class="kw">static</span> Option&lt;A&gt; <span class="fu">apply</span>(A a) {
    <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Some</span>(a);
  }

  <span class="kw">public</span> <span class="kw">class</span> Some : Option&lt;A&gt; {
    <span class="kw">readonly</span> A a;

    <span class="kw">public</span> <span class="fu">Some</span>(A a) {
      <span class="kw">this</span>.<span class="fu">a</span> = a;
    }

    <span class="kw">public</span> <span class="kw">override</span> X Fold&lt;X&gt;(Func&lt;A, X&gt; some, X none) {
      <span class="kw">return</span> <span class="fu">some</span>(a);
    }
  }

  <span class="kw">public</span> <span class="kw">class</span> None : Option&lt;A&gt; {
    <span class="kw">public</span> <span class="kw">override</span> X Fold&lt;X&gt;(Func&lt;A, X&gt; some, X none) {
      <span class="kw">return</span> none;
    }
  }
}

<span class="kw">abstract</span> <span class="kw">class</span> List&lt;A&gt; {
  <span class="kw">public</span> <span class="kw">abstract</span> X FoldRight&lt;X&gt;(Func&lt;A, X, X&gt; f, X x);

  <span class="co">// Return all the Some values, or None if not all are Some.</span>
  Option&lt;List&lt;A&gt;&gt; <span class="fu">runOptions</span>(List&lt;Option&lt;A&gt;&gt; x) {
    <span class="kw">return</span> x.<span class="fu">FoldRight</span>((a, b) =&gt; a.<span class="fu">SelectMany</span>(aa =&gt;
      b.<span class="fu">Select</span>(bb =&gt; bb.<span class="fu">Prepend</span>(aa))), Option&lt;List&lt;A&gt;&gt;.<span class="fu">apply</span>(<span class="kw">new</span> <span class="fu">Nil</span>()));
  }

  <span class="co">// Apply an Int to a list of int readers and return the list of return values.</span>
  IntRdr&lt;List&lt;A&gt;&gt; <span class="fu">runIntRdrs</span>(List&lt;IntRdr&lt;A&gt;&gt; x) {
    <span class="kw">return</span> x.<span class="fu">FoldRight</span>((a, b) =&gt; a.<span class="fu">SelectMany</span>(aa =&gt;
      b.<span class="fu">Select</span>(bb =&gt; bb.<span class="fu">Prepend</span>(aa))), IntRdr&lt;List&lt;A&gt;&gt;.<span class="fu">apply</span>(<span class="kw">new</span> <span class="fu">Nil</span>()));
  }

  <span class="kw">public</span> List&lt;A&gt; <span class="fu">Prepend</span>(A a) {
    <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Cons</span>(a, <span class="kw">this</span>);
  }

  <span class="kw">public</span> <span class="kw">class</span> Nil : List&lt;A&gt; {
    <span class="kw">public</span> <span class="kw">override</span> X FoldRight&lt;X&gt;(Func&lt;A, X, X&gt; f, X x) {
      <span class="kw">return</span> x;
    }
  }

  <span class="kw">public</span> <span class="kw">class</span> Cons : List&lt;A&gt; {
    <span class="kw">readonly</span> A head;
    <span class="kw">readonly</span> List&lt;A&gt; tail;

    <span class="kw">public</span> <span class="fu">Cons</span>(A head, List&lt;A&gt; tail) {
      <span class="kw">this</span>.<span class="fu">head</span> = head;
      <span class="kw">this</span>.<span class="fu">tail</span> = tail;
    }

    <span class="kw">public</span> <span class="kw">override</span> X FoldRight&lt;X&gt;(Func&lt;A, X, X&gt; f, X x) {
      <span class="kw">return</span> <span class="fu">f</span>(head, tail.<span class="fu">FoldRight</span>(f, x));
    }
  }
}

<span class="co">// Code Duplication</span>

<span class="co">//       *************      *******      *********</span>
<span class="co">// Option&lt;List&lt;A&gt;&gt; runOptions(List&lt;Option&lt;A&gt;&gt; x) {</span>
<span class="co">// IntRdr&lt;List&lt;A&gt;&gt; runIntRdrs(List&lt;IntRdr&lt;A&gt;&gt; x) {</span>

<span class="co">// ***********************************************</span>
<span class="co">// return x.FoldRight((a, b) =&gt; a.SelectMany(aa =&gt;</span>
<span class="co">// return x.FoldRight((a, b) =&gt; a.SelectMany(aa =&gt;</span>

<span class="co">// *********************************      ****************************</span>
<span class="co">// b.Select(bb =&gt; bb.Prepend(aa))), Option&lt;List&lt;A&gt;&gt;.apply(new Nil()));</span>
<span class="co">// b.Select(bb =&gt; bb.Prepend(aa))), IntRdr&lt;List&lt;A&gt;&gt;.apply(new Nil()));</span>

}</code></pre>
<h1 id="java">Java</h1>
<pre class="sourceCode Java"><code class="sourceCode java"><span class="kw">package RefactoringPuzzle;</span>

<span class="kw">abstract</span> <span class="kw">class</span> Func&lt;T, U&gt; {
  <span class="kw">abstract</span> U <span class="fu">apply</span>(T t);
}

<span class="kw">abstract</span> <span class="kw">class</span> IntRdr&lt;A&gt; {
  <span class="kw">abstract</span> A <span class="fu">read</span>(<span class="dt">int</span> i);

  &lt;B&gt; IntRdr&lt;B&gt; <span class="fu">map</span>(<span class="dt">final</span> Func&lt;A, B&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;B&gt;() {
      B <span class="fu">read</span>(<span class="dt">int</span> i) {
        <span class="kw">return</span> f.<span class="fu">apply</span>(IntRdr.<span class="fu">this</span>.<span class="fu">read</span>(i));
      }
    };
  }

  &lt;B&gt; IntRdr&lt;B&gt; <span class="fu">bind</span>(<span class="dt">final</span> Func&lt;A, IntRdr&lt;B&gt;&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;B&gt;() {
      B <span class="fu">read</span>(<span class="dt">int</span> i) {
        <span class="kw">return</span> f.<span class="fu">apply</span>(IntRdr.<span class="fu">this</span>.<span class="fu">read</span>(i)).<span class="fu">read</span>(i);
      }
    };
  }

  <span class="dt">static</span> &lt;A&gt; IntRdr&lt;A&gt; <span class="fu">apply</span>(<span class="dt">final</span> A a) {
    <span class="kw">return</span> <span class="kw">new</span> IntRdr&lt;A&gt;() {
      A <span class="fu">read</span>(<span class="dt">int</span> _) {
        <span class="kw">return</span> a;
      }
    };
  }
}

<span class="kw">abstract</span> <span class="kw">class</span> Option&lt;A&gt; {
  <span class="kw">abstract</span> &lt;X&gt; X <span class="fu">fold</span>(Func&lt;A, X&gt; some, X none);

  &lt;B&gt; Option&lt;B&gt; <span class="fu">map</span>(<span class="dt">final</span> Func&lt;A, B&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> Option&lt;B&gt;() {
      &lt;X&gt; X <span class="fu">fold</span>(<span class="dt">final</span> Func&lt;B, X&gt; some, X none) {
        <span class="kw">return</span> Option.<span class="fu">this</span>.<span class="fu">fold</span>(<span class="kw">new</span> Func&lt;A, X&gt;(){
          X <span class="fu">apply</span>(A a) {
            <span class="kw">return</span> some.<span class="fu">apply</span>(f.<span class="fu">apply</span>(a));
          }
        }, none);
      }
    };
  }

  &lt;B&gt; Option&lt;B&gt; <span class="fu">bind</span>(<span class="dt">final</span> Func&lt;A, Option&lt;B&gt;&gt; f) {
    <span class="kw">return</span> <span class="kw">new</span> Option&lt;B&gt;() {
      &lt;X&gt; X <span class="fu">fold</span>(<span class="dt">final</span> Func&lt;B, X&gt; some, <span class="dt">final</span> X none) {
        <span class="kw">return</span> Option.<span class="fu">this</span>.<span class="fu">fold</span>(<span class="kw">new</span> Func&lt;A, X&gt;(){
          X <span class="fu">apply</span>(A a) {
            <span class="kw">return</span> f.<span class="fu">apply</span>(a).<span class="fu">fold</span>(some, none);
          }
        }, none);
      }
    };
  }

  <span class="dt">static</span> &lt;A&gt; Option&lt;A&gt; <span class="fu">apply</span>(<span class="dt">final</span> A a) {
    <span class="kw">return</span> <span class="kw">new</span> Option&lt;A&gt;() {
      &lt;X&gt; X <span class="fu">fold</span>(Func&lt;A, X&gt; some, X none) {
        <span class="kw">return</span> some.<span class="fu">apply</span>(a);
      }
    };
  }
}

<span class="kw">abstract</span> <span class="kw">class</span> List&lt;A&gt; {
  <span class="kw">abstract</span> &lt;X&gt; X <span class="fu">foldRight</span>(Func&lt;A, Func&lt;X, X&gt;&gt; f, X x);

  <span class="co">// Return all the Some values, or None if not all are Some.</span>
  <span class="dt">static</span> &lt;A&gt; Option&lt;List&lt;A&gt;&gt; <span class="fu">runOptions</span>(List&lt;Option&lt;A&gt;&gt; x) {
    <span class="kw">return</span> x.<span class="fu">foldRight</span>(<span class="kw">new</span> Func&lt;Option&lt;A&gt;, Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt;&gt;(){
      Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> Option&lt;A&gt; a) {
        <span class="kw">return</span> <span class="kw">new</span> Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt;() {
          Option&lt;List&lt;A&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> Option&lt;List&lt;A&gt;&gt; b) {
            <span class="kw">return</span> a.<span class="fu">bind</span>(<span class="kw">new</span> Func&lt;A, Option&lt;List&lt;A&gt;&gt;&gt;(){
              Option&lt;List&lt;A&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> A aa) {
                <span class="kw">return</span> b.<span class="fu">map</span>(<span class="kw">new</span> Func&lt;List&lt;A&gt;, List&lt;A&gt;&gt;(){
                  List&lt;A&gt; <span class="fu">apply</span>(List&lt;A&gt; bb) {
                    <span class="kw">return</span> bb.<span class="fu">prepend</span>(aa);
                  }
                });
              }
            });
          }
        };
      }
    }, Option.<span class="fu">apply</span>(List.&lt;A&gt;<span class="fu">nil</span>()));
  }

  <span class="co">// Apply an Int to a list of int readers and return the list of return values.</span>
  <span class="dt">static</span> &lt;A&gt; IntRdr&lt;List&lt;A&gt;&gt; <span class="fu">runIntRdrs</span>(List&lt;IntRdr&lt;A&gt;&gt; x) {
    <span class="kw">return</span> x.<span class="fu">foldRight</span>(<span class="kw">new</span> Func&lt;IntRdr&lt;A&gt;, Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt;&gt;(){
      Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> IntRdr&lt;A&gt; a) {
        <span class="kw">return</span> <span class="kw">new</span> Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt;() {
          IntRdr&lt;List&lt;A&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> IntRdr&lt;List&lt;A&gt;&gt; b) {
            <span class="kw">return</span> a.<span class="fu">bind</span>(<span class="kw">new</span> Func&lt;A, IntRdr&lt;List&lt;A&gt;&gt;&gt;(){
              IntRdr&lt;List&lt;A&gt;&gt; <span class="fu">apply</span>(<span class="dt">final</span> A aa) {
                <span class="kw">return</span> b.<span class="fu">map</span>(<span class="kw">new</span> Func&lt;List&lt;A&gt;, List&lt;A&gt;&gt;(){
                  List&lt;A&gt; <span class="fu">apply</span>(List&lt;A&gt; bb) {
                    <span class="kw">return</span> bb.<span class="fu">prepend</span>(aa);
                  }
                });
              }
            });
          }
        };
      }
    }, IntRdr.<span class="fu">apply</span>(List.&lt;A&gt;<span class="fu">nil</span>()));
  }

  List&lt;A&gt; <span class="fu">prepend</span>(<span class="dt">final</span> A a) {
    <span class="kw">return</span> <span class="kw">new</span> List&lt;A&gt;() {
      &lt;X&gt; X <span class="fu">foldRight</span>(Func&lt;A, Func&lt;X, X&gt;&gt; f, X x) {
        <span class="kw">return</span> f.<span class="fu">apply</span>(a).<span class="fu">apply</span>(<span class="kw">this</span>.<span class="fu">foldRight</span>(f, x));
      }
    };
  }

  <span class="dt">static</span> &lt;A&gt; List&lt;A&gt; <span class="fu">nil</span>() {
    <span class="kw">return</span> <span class="kw">new</span> List&lt;A&gt;() {
      &lt;X&gt; X <span class="fu">foldRight</span>(Func&lt;A, Func&lt;X, X&gt;&gt; f, X x) {
        <span class="kw">return</span> x;
      }
    };
  }
}

<span class="co">// Code Duplication</span>

<span class="co">// ***********      *************      *******      *********</span>
<span class="co">// static &lt;A&gt; Option&lt;List&lt;A&gt;&gt; runOptions(List&lt;Option&lt;A&gt;&gt; x) {</span>
<span class="co">// static &lt;A&gt; IntRdr&lt;List&lt;A&gt;&gt; runIntRdrs(List&lt;IntRdr&lt;A&gt;&gt; x) {</span>

<span class="co">//   ****************************      **********      ***********      **************</span>
<span class="co">//   return x.foldRight(new Func&lt;Option&lt;A&gt;, Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt;&gt;(){</span>
<span class="co">//   return x.foldRight(new Func&lt;IntRdr&lt;A&gt;, Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt;&gt;(){</span>

<span class="co">//     *****      ***********      ***********************      ********</span>
<span class="co">//     Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt; apply(final Option&lt;A&gt; a) {</span>
<span class="co">//     Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt; apply(final IntRdr&lt;A&gt; a) {</span>

<span class="co">//       ****************      ***********      **************</span>
<span class="co">//       return new Func&lt;Option&lt;List&lt;A&gt;&gt;, Option&lt;List&lt;A&gt;&gt;&gt;() {</span>
<span class="co">//       return new Func&lt;IntRdr&lt;List&lt;A&gt;&gt;, IntRdr&lt;List&lt;A&gt;&gt;&gt;() {</span>

<span class="co">//               **********************      **************</span>
<span class="co">//         Option&lt;List&lt;A&gt;&gt; apply(final Option&lt;List&lt;A&gt;&gt; b) {</span>
<span class="co">//         IntRdr&lt;List&lt;A&gt;&gt; apply(final IntRdr&lt;List&lt;A&gt;&gt; b) {</span>

<span class="co">//           **************************      *************</span>
<span class="co">//           return a.bind(new Func&lt;A, Option&lt;List&lt;A&gt;&gt;&gt;(){</span>
<span class="co">//           return a.bind(new Func&lt;A, IntRdr&lt;List&lt;A&gt;&gt;&gt;(){</span>

<span class="co">//                   *****************************</span>
<span class="co">//             Option&lt;List&lt;A&gt;&gt; apply(final A aa) {</span>
<span class="co">//             IntRdr&lt;List&lt;A&gt;&gt; apply(final A aa) {</span>

<span class="co">//               ******************************************</span>
<span class="co">//               return b.map(new Func&lt;List&lt;A&gt;, List&lt;A&gt;&gt;(){</span>
<span class="co">//               return b.map(new Func&lt;List&lt;A&gt;, List&lt;A&gt;&gt;(){</span>

<span class="co">//                 ***************************</span>
<span class="co">//                 List&lt;A&gt; apply(List&lt;A&gt; bb) {</span>
<span class="co">//                 List&lt;A&gt; apply(List&lt;A&gt; bb) {</span>

<span class="co">//                   **********************</span>
<span class="co">//                   return bb.prepend(aa);</span>
<span class="co">//                   return bb.prepend(aa);</span>
  …
<span class="co">//   ***      ***********************</span>
<span class="co">//   }, Option.apply(List.&lt;A&gt;nil()));</span>
<span class="co">//   }, IntRdr.apply(List.&lt;A&gt;nil()));</span>
  …</code></pre>]]></summary>
</entry>

</feed>
